(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "856857e"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "cfa630d"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "1616a3a"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "956a8bb"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "b41dd1d"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "e67c808"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "8aabae3"))

(inline C "
#include \"llvm-c/Core.h\"
#include \"llvm-c/ExecutionEngine.h\"
#include \"llvm-c/Target.h\"


void destroy_llvm_context(void *ctx) {
    if(ctx) {
        printf(\"Disposing context: %p\\n\", ctx);
        LLVMContextDispose((LLVMContextRef)ctx);
    }
}

void dispose_llvm_module(void *module) {
    if (module) {
        printf(\"Disposing module: %p\\n\", module);
        LLVMDisposeModule((LLVMModuleRef)module);
    }
}
")

(defn llvm-context-create []
    (inline C Maybe "
        LLVMContextRef ctx = LLVMContextCreate();

        if (ctx) {
            printf(\"Context ref: %p\\n\", ctx);
            Value* v = opaqueValue(ctx, &destroy_llvm_context);
            return(maybe((List *)0, (Value *)0, v));
        } else {
            return(nothing);
        }
    "))

(defn llvm-context-create-module [context name]
    (inline C Maybe "
        LLVMContextRef ctx = ((Opaque*)context_0)->ptr;
        String* nameStr = nullTerm(name_1);
        printf(\"Context ref in create-module: %p\\n\", ctx);
        LLVMModuleRef mod = LLVMModuleCreateWithNameInContext(nameStr->buffer, ctx);

        if (mod) {
            Value *v = opaqueValue(mod, &dispose_llvm_module);
            printf(\"Module ref: %p\\n\", mod);
            dec_and_free((Value *)nameStr, 1);
            return maybe((List *)0, (Value *)0, v);
        } else {
            dec_and_free((Value *)nameStr, 1);
            return nothing;
        }
    "))

(defn llvm-link-in-interpreter []
    (inline C Integer "LLVMLinkInInterpreter();"))

(defn llvm-initialize-all-target-infos []
    (inline C "LLVMInitializeAllTargetInfos(); return integerValue(1);"))

(defn llvm-initialize-native-target []
    (inline C "
        if (0 == LLVMInitializeNativeTarget()) {
            return maybe((List *)0, (Value *)0, integerValue(1));
        } else {
            return nothing;
        }"))

(defn llvm-initialize-native-asm-parser []
    (inline C "
        if (0 == LLVMInitializeNativeAsmParser()) {
            return maybe((List *)0, (Value *)0, integerValue(1));
        } else {
            return nothing;
        }"))

(defn llvm-initialize-native-asm-printer []
    (inline C "
        if (0 == LLVMInitializeNativeAsmPrinter()) {
            return maybe((List *)0, (Value *)0, integerValue(1));
        } else {
            return nothing;
        }"))

(defn llvm-initialize-native-disassembler []
    (inline C "
        if (0 == LLVMInitializeNativeDisassembler()) {
            return maybe((List *)0, (Value *)0, integerValue(1));
        } else {
            return nothing;
        }"))

(defn list-targets []
  (inline C List "
    List *output = empty_list;
    Value *item;
    LLVMTargetRef target = LLVMGetFirstTarget();

    if (target == NULL) {
        printf(\"Really? No targets? Not one little letter?\\n\");
    }

    while (target != NULL) {
        char* targetName = LLVMGetTargetName(target);

        if (targetName != NULL) {
            output = listCons(stringValue(targetName), output);
        }

        target = LLVMGetNextTarget(target);
    }

    return (Value*)output;"))

(defn llvm-get-default-target-triple []
    (inline C  "return stringValue(LLVMGetDefaultTargetTriple());"))

(defprotocol CodeEmitter
  (codegen [this context module ] "Emit code in the given context and module."))

;(defrecord OpPlus [lhs rhs]
;  (codegen [this context module ]
;    (let [left-code (codegen lhs context module builder)
;          right-code (codegen rhs context module builder)]
;        (create-fadd builder left-code right-code "addtmp"))))

(defn emit-int-expr [context module val]
    (inline C "
        LLVMContextRef ctx = ((Opaque*)context_0)->ptr;
        int64_t v = ((Integer*)val_2)->numVal;
        LLVMTypeRef type = LLVMInt64TypeInContext(ctx);
        dec_and_free(val_2, 1);
        return opaqueValue(LLVMConstReal(type, v), NULL);"))

(deftype ConstInt [val]
  CodeEmitter
  (codegen [this context module]
    (emit-int-expr context module val)))

(main [& args]
    (llvm-initialize-all-target-infos)

    (println "Available targets: " (list-targets))

    (or
        (and 
            (llvm-initialize-native-target)
            (llvm-initialize-native-asm-parser)
            (llvm-initialize-native-asm-printer)
            (llvm-initialize-native-disassembler))
        (println "Cannot initialize native target"))

    (let [llvm (llvm-context-create)
          x    (llvm-context-create-module (extract llvm) "foo")]
        (println "llvm has value?" (and llvm "yes"))
        (println "module has value?" (and x "yes"))

        (codegen (ConstInt 12345) (extract llvm) x)

        (println "This is the day")))


