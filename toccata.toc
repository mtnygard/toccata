
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "4e060ab"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "cfa630d"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "1616a3a"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "bed3aa7"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "b41dd1d"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "e67c808"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "22fc8c6"))

(def line-sep " ")

(defn line-macro [ast marker]
  (sm/state-maybe (either (= "" (ast/file-name ast))
                          ["\n" marker "\n#line "
                           (str (ast/line-number ast)) " " "\""
                           (ast/file-name ast) "\"\n"])))

(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -1, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -1, IntegerType};"))
(def StringType (inline C Integer "(Value *)&(Integer){IntegerType, -1, StringType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FunctionType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ListType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, MaybeType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SymbolType};"))
(def BitmapIndexedType
  (inline C Integer "(Value *)&(Integer){IntegerType, -1, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ArrayNodeType};"))
(def HashCollisionNodeType
  (inline C Integer "(Value *)&(Integer){IntegerType, -1, HashCollisionNodeType};"))
(def HashMapType (inline C Integer "(Value *)&(Integer){IntegerType, -1, HashMapType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -1, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -1, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -1, OpaqueType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -1, TypeCount};"))

(def type-names {IntegerType "Integer"
                 StringType "String"
                 FnArityType "FnArity"
                 FunctionType "Function"
                 SubStringType "SubString"
                 ListType "List"
                 MaybeType "Maybe"
                 VectorType "Vector"
                 VectorNodeType "VectorNode"
                 SymbolType "Symbol"
                 BitmapIndexedType "BitmapIndexNode"
                 ArrayNodeType "ArrayNode"
                 HashCollisionNodeType "HashCollisionNode"
                 HashMapType "HashMap"
                 PromiseType "Promise"
                 FutureType "Future"
                 AgentType "Agent"
                 OpaqueType "Opaque"})

(defn target-type-name [n]
  (either (get type-names n)
          (str n)))

(def core-types {'Integer IntegerType
                 'String StringType
                 'SubString SubStringType
                 'FnArity FnArityType
                 'Function FunctionType
                 'List ListType
                 'Maybe MaybeType
                 'Vector VectorType
                 'Symbol SymbolType
                 'BitmapIndexedNode BitmapIndexedType
                 'ArrayNode ArrayNodeType
                 'HashCollisionNode HashCollisionNodeType
                 'HashMap HashMapType
                 'Promise PromiseType
                 'Future FutureType
                 'Agent AgentType
                 'Opaque OpaqueType
                 'TypeCount TypeCount})

(def sm-space (sm/state-maybe ""))

;; useful for debugging the compiler
(defn debug [& args]
  (map sm-space (fn [_] (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (sm/new-sm (fn [s]
               (apply print-err msg)
               (abort))))

(deftype ConstantValues [numbers strings symbols type-names]
  ;; numbers                static numbers
  ;; strings                static strings
  ;; symbols                static symbols
  ;; type-names             map of type numbers to type names
  )

(deftype RuntimeInit [fn-context exprs]
  ;; fn-context        context for the initialization code
  ;; exprs             the init expressions
  )

;; information that must be tracked for each module
(deftype Module [path values protocols proto-fns types declarations]
  ;; path             path to file containing the modules source code
  ;; values           map of value symbols to defined values
  ;; protocols        set of protocol symbols
  ;; proto-fns        map of protocol fn symbols to fn information
  ;; types            map of type symbols to type definitions
  ;; declarations     map of symbols to C vars that have not been defined
  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

;; There's a bunch of information to keep track of while compiling
(deftype GlobalContext [target-lang fn-context init modules
                        fns namespaces constants reify-fn-index]
  ;; target-lang            language to compile to
  ;; fn-context             context for the fn currently being compiled
  ;; modules                info for each module compiled
  ;; numbers                static numbers
  ;; strings                static strings
  ;; fns                    static functions
  ;; namespaces             current namespace map
  Stringable
  (string-list [_] (list "<GlobalContext>"))
)

(deftype Closures [closures refs-map])
(def empty-closures (Closures empty-list {}))

;; Every function arity has some information that's local to it
(deftype FunctionArityContext [recurse sym-count syms context closed-over]
  ;; recurse       info to detect recursive calls
  ;; sym-count     number of C variables already used in this fn
  ;; syms          the symbols local to the function that are currently interned
  ;; context
  ;; closed-over   symbols that this function closes over
  Stringable
  (string-list [_]
    (list "<FunctionArityContext " (str (count syms)) ">")))

(defn reset-fn-context
  ([]
   (for [curr-fn-context (sm/get-val .fn-context)
         :let [new-context (comp (.context curr-fn-context) (.syms curr-fn-context))]
         _ (sm/set-val .fn-context (FunctionArityContext {} 0 {} new-context empty-closures))]
     curr-fn-context))
  ([new-fn-context]
   (for [curr-fn-context (sm/get-val .fn-context)
         _ (sm/set-val .fn-context new-fn-context)]
     curr-fn-context)))

(defprotocol Emitter
  ;; For AST nodes that can be embedded in other AST nodes
  (emit [_])

  ;; For AST nodes that can be assigned to a symbol at the top level
  (emit-defined-value [ast defined-sym])

  ;; For AST nodes that can appear at the top level of a file
  (emit-definition [_])

  ;; Mark this AST node as the final (or tail) expression in a function body
  (tail-call [_ params])

  ;; Does 'ast' produce any executable code when emitted?
  (produces-code? [ast] (maybe ast))

  ;; Emit a call expression if the call target is a tagged-symbol. Otherwise, fail
  (emit-call-expr [target-ast args]
    (zero sm/state-maybe))

  ;; replace all occurances of the keys in 'subs' with their associated values
  (replace-syms [ast subs])

  ;; prepend "#" to all the bound variables in the AST
  (replace-bound-vars [ast subs]
    ast)

  ;; expand 'target-ast' so that it's component asts are inlined
  (inline-expr [target-ast arg-asts]
    (zero sm/state-maybe))

  ;; generate a new local C var for a symbol
  (bind [binding])

  ;; bind the symbol 'binding' to the results of 'evalled'
  (bind [binding evalled]))

;; combine a sequence of expressions, adding reference increments and decrements
;; where needed
(defprotocol CollapseExprs
  (collapse-expressions* [x y]))

;; information about a compiled expression(s)
;; c-var: C variable that holds the value produced by the code
;; init: C code that produces the value at run time
;; decl: C code to declare anything needed
;; type-num: the Toccata type of the value produced
;; refs-map: map of C variables that are used in 'init' and how many times
(deftype empty-code [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<Empty-C-Code>"))

  Collection
  (empty? [c]
    (maybe c))

  Composition
  (zero [c] c)
  (comp* [_ cs]
    (apply comp cs))

  CollapseExprs
  (collapse-expressions* [x y] y)

  Emitter
  (emit [x]
    (sm/state-maybe x)))

(def empty-c-code (empty-code "" [] [] UnknownType {}))

(deftype c-code [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", " (target-type-name type-num) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ">"))

  Composition
  (zero [_] empty-c-code)
  (comp* [c cs]
    (reduce cs c collapse-expressions*))

  Collection
  (empty? [c]
    (and (empty? (.init c))
         (empty? (.decl c))))

  CollapseExprs
  (collapse-expressions* [x y]
    (c-code (.c-var y)
            [(.init x) (.init y)]
            [(.decl x) (.decl y)]
            (.type-num y)
            (merge-with + (.refs-map x) (.refs-map y))))

  Emitter
  (emit [x]
    (sm/state-maybe x)))

;; same as 'c-code', but is the first appearance of 'c-var' in the generated code
(deftype c-init [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<C-Init " (str c-var) ", " (target-type-name type-num) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ">"))

  Collection
  (empty? [c] nothing)

  Composition
  (zero [_] empty-c-code)
  (comp* [c cs]
    (reduce cs c (fn [result c]
                   (c-code (.c-var c)
                           [(.init result) (.init c)]
                           [(.decl result) (.decl c)]
                           (.type-num c)
                           (merge-with + (.refs-map result) (.refs-map c))))))

  CollapseExprs
  (collapse-expressions* [x y]
    (let [init (either (or (for [refs (get-in y [.refs-map c-var])]
                              [(.init x)
                               ((< refs 2) "" [line-sep "incRef(" c-var ", " (dec refs) ");" line-sep])
                               (.init y)])
                            (and (= "" c-var)
                                 (maybe [(.init x) (.init y)])))
                       [(.init x)
                        line-sep "dec_and_free(" c-var ", 1);" line-sep
                        (.init y)])
          refs-map (merge-with + (.refs-map x) (.refs-map y))
          refs-map (assoc refs-map c-var 0)]
      (c-code (.c-var y)
              init
              [(.decl x) (.decl y)]
              (.type-num y)
              refs-map)))

  Emitter
  (emit [x]
    (sm/state-maybe x)))

(defn collapse-expressions [cs]
  (either (and (empty? cs) (maybe empty-c-code))
          (let [[c & cs] (reverse cs)
                cs (remove cs empty?)]
            (reduce cs c (fn [y x]
                           (collapse-expressions* x y))))))

(defn sym-ns-path [sym]
  (comp (for [ns-sym (sm/when (rdr/namespace sym))
              path (sm/get-in-val [.namespaces (ast/file-name sym) ns-sym])]
          path)
        (sm/state-maybe (ast/file-name sym))))

(defn new-protocol [proto-sym]
  ;; Initialize a new protocol definition in a module if it does not already exist.
  ;; Ensure all protocol symbols are unique
  (comp (for [_ (sm/get-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym])
              _ (compilation-error "Duplicate protocol" (str "'" proto-sym "'") "at"
                                   (str (ast/file-name proto-sym) ":")
                                   (ast/line-number proto-sym))]
          "")
        (sm/assoc-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym]
                         proto-sym)))

(defn get-protocol [proto-sym]
  ;; Look for the protocol information
  ;; 1. using the namespace portion of the protocol symbol
  ;; 2. using `'core` for protcols defined in the core
  (comp (for [protocol-path (sym-ns-path proto-sym)
              proto-info (sm/get-in-val [.modules protocol-path .protocols proto-sym])]
          proto-info)
        (sm/get-in-val [.modules 'core .protocols proto-sym])))

(deftype ProtoFnInfo [fn-sym disp-sym dispatchers]
  Stringable
  (string-list [_] (list "<ProtoFnInfo " fn-sym ">")))

(defn new-protocol-fn [fn-sym disp-sym]
  (comp (for [_ (sm/get-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym])
              _ (compilation-error "Duplicate protocol function" (str "'" fn-sym "'") "at"
                                   (str (ast/file-name fn-sym) ":") (ast/line-number fn-sym))]
          "")
        (sm/assoc-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym]
                         (ProtoFnInfo fn-sym disp-sym {}))))

(defn lookup-protocol-path [fn-sym path]
  ;; is protocol function `fn-sym` declared in module at 'path'
  (map (sm/get-in-val [.modules path .proto-fns fn-sym])
       (fn [_] path)))

(defn find-protocol-path [fn-sym]
  (comp (for [namespace (sym-ns-path fn-sym)
              path (lookup-protocol-path fn-sym namespace)]
          path)
        (lookup-protocol-path fn-sym (ast/file-name fn-sym))
        (lookup-protocol-path fn-sym 'core)))

(deftype ProtocolDispatcher [arg-count dispatch-sym impls-sym type-impls]
  Stringable
  (string-list [_] (list "<ProtoDispatcher " (str arg-count) ">")))

(defn new-proto-dispatcher [fn-sym arg-count dispatch-sym impls-sym]
  (sm/assoc-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym .dispatchers arg-count]
                   (ProtocolDispatcher arg-count dispatch-sym impls-sym {})))

(defn get-protocol-dispatcher [fn-sym num-args]
  (for [protocol-path (find-protocol-path fn-sym)
        result (sm/get-in-val [.modules protocol-path .proto-fns fn-sym .dispatchers num-args])]
    result))

(deftype ProtoImpl [dispatch-type c-var ast]
  Stringable
  (string-list [_] (list "<ProtoImpl " (target-type-name dispatch-type) " " c-var ">")))

(defn new-proto-impl [fn-name arg-count dispatch-type c-code ast]
  (for [protocol-path (find-protocol-path fn-name)
        _ (sm/assoc-in-val [.modules protocol-path .proto-fns fn-name
                            .dispatchers arg-count .type-impls dispatch-type]
                           (ProtoImpl dispatch-type (.c-var c-code) ast))]
    ""))

(defn get-proto-impl [fn-name arg-count type-num]
  (for [protocol-path (find-protocol-path fn-name)
        impl-info (sm/get-in-val [.modules protocol-path .proto-fns fn-name
                                  .dispatchers arg-count .type-impls type-num])]
    impl-info))


(def C-var-punct (grmr/any (grmr/apply-fn (constantly "_STAR_")
                                          (grmr/ignore "*"))
                           (grmr/apply-fn (constantly "_HASH_")
                                          (grmr/ignore "#"))
                           (grmr/apply-fn (constantly "_PLUS_")
                                          (grmr/ignore "+"))
                           (grmr/apply-fn (constantly "_QM_")
                                          (grmr/ignore "?"))
                           (grmr/apply-fn (constantly "_BANG_")
                                          (grmr/ignore "!"))
                           (grmr/apply-fn (constantly "_EQ_")
                                          (grmr/ignore "="))
                           (grmr/apply-fn (constantly "_LT_")
                                          (grmr/ignore "<"))
                           (grmr/apply-fn (constantly "_GT_")
                                          (grmr/ignore ">"))))

(def C-var-remaining
  (grmr/none-or-more (grmr/any "_"
                               (grmr/apply-fn (constantly "_")
                                              (grmr/ignore "-"))
                               grmr/alpha
                               grmr/digit
                               C-var-punct)))

(def C-var (grmr/apply-fn (fn [start remaining]
                            (apply str start remaining))
                          (grmr/any grmr/alpha
                                    (map (grmr/ignore "#") (fn [] ""))
                                    (map (grmr/ignore "-") (fn [] "_MINUS_"))
                                    C-var-punct)
                          C-var-remaining))

(def check-C-var (rd/parser C-var))

(defn genlocal
  ([pre]
   (for [sym-count (sm/get-in-val [.fn-context .sym-count])
         _ (sm/assoc-in-val [.fn-context .sym-count] (inc sym-count))]
     (symbol (str pre sym-count))))
  ([sym arg-name]
   (for [sym-count (sm/get-in-val [.fn-context .sym-count])
         _ (sm/assoc-in-val [.fn-context .sym-count] (inc sym-count))]
     (symbol (str (either (check-C-var (str sym "_"))
                          arg-name)
                  sym-count)))))

(defn redef-proto-fn-error [sym]
  (for [path (find-protocol-path sym)
        _ (compilation-error "Redefining" (str "'" sym "'") "at"
                             (str (ast/file-name sym) ":") (ast/line-number sym)
                             "which is a protocol function in" path)]
    ""))

(deftype ParamBinding [vars destruct]
  Stringable
  (string-list [_]
    (comp (list "<ParamBinding ")
          (string-list vars)
          (list " ")
          (string-list destruct)
          (list ">")))

  Composition
  (comp* [x xs]
    (let [xs (cons x xs)]
      (ParamBinding (flat-map xs .vars) (flat-map xs .destruct)))))


(defn traverse [asts f]
  (reduce (reverse asts) (sm/state-maybe empty-list)
            (fn [l ast]
              (flat-map (f ast)
                        (fn [emitted]
                          (map l (fn [x]
                                   (cons emitted x))))))))

(extend-type List
  Emitter
  (emit [asts]
    (traverse asts emit))

  (tail-call [asts args]
    (let [asts (-> asts
                   (filter produces-code?)
                   reverse)]
      (either (empty? asts)
              (let [[tail & init] asts]
                (-> (tail-call tail args)
                    (cons init)
                    reverse))))))

(extend-type Vector
  Emitter
  (emit [asts]
    (traverse asts emit))

  (tail-call [asts params]
    (let [asts (-> asts
                   (filter produces-code?)
                   reverse)]
      (extract (or (empty? asts)
                   (flat-map (last asts)
                             (fn [tail]
                               (store asts (dec (count asts))
                                      (tail-call tail params)))))))))

;; generate symbols that are available globally inside the 'state-maybe' container
(defn global-var
  ([arg-name] (sm/state-maybe (gensym arg-name)))
  ([sym arg-name]
   (sm/state-maybe (gensym (either (check-C-var (str sym "_"))
                                   arg-name)))))


(defn lookup-module-def [sym]
  (let [sym-file (ast/file-name sym)]
    (comp (for [_ (sm/when (rdr/namespace sym))
                ns-file (sym-ns-path sym)
                var (comp (sm/get-in-val [.modules ns-file .values (.base sym)])
                          (sm/get-in-val [.modules ns-file .values (rdr/tag (.base sym))]))]
            var)
          (sm/get-in-val [.modules sym-file .values sym]))))

(defn new-module-def [sym value]
  (comp (redef-proto-fn-error sym)
        (for [r (sm/assoc-in-val [.modules (ast/file-name sym) .values sym] value)
              _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym] nothing)]
          r)))

(defn lookup-declaration [sym]
  (sm/get-in-val [.modules (ast/file-name sym) .declarations sym '_]))

(defn lookup-core-def [sym]
  (sm/get-in-val [.modules 'core .values sym]))

(defn already-closed-over [sym]
  (for [closed-over (sm/get-in-val [.fn-context .closed-over .closures])
        closure-var (sm/when (some closed-over (fn [[closure-var sym-literal]]
                                                 (for [_ (= sym sym-literal)]
                                                   closure-var))))
        _ (sm/update-in-val [.fn-context .closed-over .refs-map closure-var] inc)]
    closure-var))

(defn new-closure [sym]
  (for [closure-var (genlocal "val")
        _ (sm/update-in-val [.fn-context .closed-over .closures]
                            (fn [v] (conj v [closure-var sym])))
        _ (sm/assoc-in-val [.fn-context .closed-over .refs-map closure-var] 1)]
    closure-var))

(defn closed-over-sym [sym]
  (for [;; it's supposed to fail if 'sym' is not in the context
        c-sym (sm/get-in-val [.fn-context .context sym])

        ;; if 'sym' is in the context, it should be in .closed-over
        closure-var (comp (already-closed-over sym)
                          (new-closure sym))]
    (c-code closure-var [] [] (.type-num c-sym) {closure-var 1})))

(defn lookup-sym [sym]
  (comp (for [_ (sm/when-not (rdr/namespace sym))
              r (comp (sm/get-in-val [.fn-context .syms sym])
                      (closed-over-sym sym))]
          r)
        (comp (lookup-module-def sym)
              (lookup-declaration sym)
              (lookup-core-def sym)
              (compilation-error "Undefined symbol" (str "'" sym "'") "at"
                                 (str (ast/file-name sym) ":")
                                 (ast/line-number sym)))))

;; we cache all the info about static function arities to optimize call sites
(defn lookup-static-arity [fn-var num-params]
  (sm/get-in-val [.fns fn-var num-params]))

(defn new-static-arity [fn-var num-params arity-var type-num]
  (sm/assoc-in-val [.fns fn-var num-params]
                   (c-code arity-var [] [] type-num {})))

(defn lookup-core-fn-arity [sym num-args]
  (for [fn-sym (sm/get-in-val [.modules 'core .values sym])
        arity-sym (lookup-static-arity (.c-var fn-sym) num-args)]
    arity-sym))


(extend-type ast/block-comment-ast
  Emitter
  (produces-code? [ast] nothing)

  (emit [ast]
    (sm/state-maybe (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            [] 0 {})))

  (emit-defined-value [_ _] (sm/state-maybe []))
  (emit-definition [_] (sm/state-maybe []))

  (tail-call [ast params] ast))


(defn make-static-string [str-val]
  (let [str-len (count str-val)]
    (for [str-idx (map (sm/get-in-val [.constants .strings]) count)
          :let [str-sym (str "str" str-idx)
                str-ptr (str "strPtr" str-idx)]
          _ (sm/assoc-in-val [.constants .strings str-val] (c-code str-ptr [] [] StringType {}))]
      (c-init str-ptr
              []
              ["struct {int64_t type;
        int32_t refs;
        int64_t len;
        Integer *hash;
        char buffer["
               (inc str-len)
               "];\n} " str-sym " = {StringType, -1, "
               str-len ", 0, \"" (escape-chars str-val) "\"};\n"
               "Value *" str-ptr " = (Value *)&" str-sym ";\n"]
              StringType {}))))

(defn make-c-code [value]
  (c-code (.c-var value) (.init value) (.decl value) (.type-num value) (.refs-map value)))

(deftype TailExpr [ast params]
  Stringable
  (string-list [expr]
    (comp (list "<TailExpr ") (string-list ast) (list ">")))

  Emitter
  (emit [_]
    (comp (for [_ (sm/when (and (instance? ast/call-ast ast)
                                (or (instance? Symbol (.call-target ast))
                                    (instance? rdr/tagged-symbol (.call-target ast)))))
                target (emit (.call-target ast))
                arity-info (sm/get-in-val [.fn-context .recurse (.c-var target) (count (.args ast))])
                args (-> (.args ast)
                         (filter produces-code?)
                         emit)
                line (line-macro ast "// recursive-fixed")]
            (collapse-expressions (comp args [(c-init ""
                                                      [line
                                                       (map (zip-lists params (map args .c-var))
                                                            (fn [[param arg]]
                                                              [param " = " arg ";" line-sep]))]
                                                      [] (.type-num arity-info)
                                                      (reduce (map args .c-var) {}
                                                              (fn [m arg]
                                                                (assoc m arg 1))))])))
          (map (emit ast) (fn [expr]
                            (.init expr [(.init expr) "return(" (.c-var expr) ");" line-sep]))))))

(extend-type String
  Emitter
  (emit [str-val]
    (comp (sm/get-in-val [.constants .strings str-val])
          (make-static-string str-val)))

  (emit-defined-value [str-val defined-sym]
    (for [value (emit str-val)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] StringType {}))]
      [(make-c-code value)]))

  (tail-call [x params] (TailExpr x params)))


(defn make-static-num [num]
  (for [num-idx (map (sm/get-in-val [.constants .numbers]) count)
        :let [num-sym (str "num" num-idx)
              num-ptr (str "numPtr" num-idx)]
        _ (sm/assoc-in-val [.constants .numbers num]
                           (c-code num-ptr [] [] IntegerType {}))]
    (c-init num-ptr
            []
            ["Integer " num-sym " = {IntegerType, -1, " num "};\n"
             "Value *" num-ptr " = (Value *)&" num-sym ";\n"]
            IntegerType {})))

(extend-type Integer
  Emitter
  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast)

  (emit [num]
    (comp (sm/get-in-val [.constants .numbers num])
          (make-static-num num)))

  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] IntegerType {}))]
      [(make-c-code value)]))

  (tail-call [x params] (TailExpr x params)))


(extend-type ast/quoted-ast
  Emitter
  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast)

  (emit [ast]
    (let [sym (.q-val ast)]
      (comp (sm/get-in-val [.constants .symbols sym])
            (for [sym-idx (map (sm/get-in-val [.constants .symbols]) count)
                  :let [sym-var (str "sym" sym-idx)
                        sym-ptr (str "symPtr" sym-idx)]
                  _ (sm/assoc-in-val [.constants .symbols sym]
                                     (c-code sym-ptr [] [] SymbolType {}))]
              (c-code sym-ptr
                      []
                      ["SubString " sym-var " = {SymbolType, -1, " (count (str sym))
                       ", 0, 0, \"" sym "\"};\n"
                       "Value *" sym-ptr " = (Value *)&" sym-var ";\n"]
                      SymbolType {})))))

  (emit-defined-value [ast defined-sym]
    (for [quoted (emit ast)
          _ (new-module-def defined-sym (c-code (.c-var quoted) [] [] SymbolType {}))]
      [(make-c-code quoted)]))

  (tail-call [ast params] (TailExpr ast params)))


(defn call-vector [target args]
  (for [_ (sm/when (= target 'vector))
        vect-sym (genlocal "newVect")
        result-sym (genlocal "rslt")
        line (line-macro target "// call-vector")]
    (apply comp (comp args
                      [(c-init result-sym
                               [line
                                "Vector *" vect-sym " = empty_vect;" line-sep
                                (map args
                                     (fn [arg]
                                       (let [arg-sym (.c-var arg)]
                                         [vect-sym " = mutateVectConj(" vect-sym ", "
                                          arg-sym ");" line-sep])))
                                "Value *" result-sym " = (Value *)" vect-sym ";" line-sep]
                               [] VectorType {})]))))

(defn call-list [target args]
  (for [_ (sm/when (= target 'list))
        line (line-macro target "// call-list")
        list-sym (genlocal "newList")
        result-sym (genlocal "rslt")]
    (apply comp (comp args
                      [(c-init result-sym
                                [line "List *" list-sym " = empty_list;" line-sep
                                 (map (reverse args)
                                      (fn [arg]
                                        (let [arg-sym (.c-var arg)]
                                          [list-sym " = listCons(" "(Value *)" arg-sym
                                           ", " list-sym ");" line-sep])))
                                 "Value *" result-sym " = (Value *)" list-sym ";" line-sep]
                                [] ListType {})]))))

(defn dispatch-type-known [target args]
  (let [num-args (count args)]
    (for [dispatch-val (sm/when (first args))
          impl-info (get-proto-impl target num-args (.type-num dispatch-val))
          arity-info (lookup-static-arity (.c-var impl-info) num-args)
          result-sym (genlocal "rslt") 
          line (line-macro target (str "// type-known for " target))]
      (let [return-type (either (or (and (= (.type-num arity-info) UnknownType)
                                         ;; TODO: these should be the result of
                                         ;; asserts on the protocol fn defs
                                         (or (= target 'map)
                                             (= target 'rest))
                                         (maybe (.type-num dispatch-val)))
                                    ;; TODO: totally speculative
                                    (and (or (= target 'first)
                                             (= target 'last)
                                             (= target 'nth)
                                             (= target 'store)
                                             (= target 'get)
                                             (= target '=*)
                                             (= target '<*)
                                             (= target 'empty?)
                                             (= target 'instance?))
                                         (maybe MaybeType)))
                                (.type-num arity-info))]
        (apply comp (comp args
                          [(c-init result-sym
                                   [line "Value *" result-sym " = " (.c-var arity-info) "("
                                    (interpose (conj (map args .c-var) "empty_list")
                                               ", ")
                                    ");" line-sep]
                                   []
                                   return-type {})]))))))

(defn dispatch-type-unknown [target args]
  (let [num-args (count args)]
    (for [impls-sym (map (get-protocol-dispatcher target num-args) .impls-sym)
          result-sym (genlocal "rslt")
          line (line-macro target (str "// type-unknown " target))]
      (apply comp (comp args
                        [(c-init result-sym
                                 [line "Value *" result-sym " = proto" num-args "Arg(&"
                                  impls-sym ", \"" (.sym target) "\", "
                                  (interpose (comp (map args .c-var)
                                                   [(str "\"" (.file-name target) "\"")
                                                    (ast/line-number target)])
                                             ", ")
                                  ");" line-sep]
                                 []
                                 UnknownType {})])))))

(defn call-proto-impl [name args]
  (for [_ (sm/when (< 0 (count args)))
        call-info (comp (dispatch-type-known name args)
                        (dispatch-type-unknown name args))]
    call-info))

(defn inline-wrap-and-apply* [name args]
  (let [num-args (count args)]
    (for [_ (sm/when (and (< 0 num-args)
                          (or (= 'wrap name)
                              (= 'apply* name))))
          :let [[dispatch-ast & arg-asts] args]
          dispatch-val (emit dispatch-ast)
          impl-ast (map (get-proto-impl name num-args (.type-num dispatch-val))
                        .ast)
          expr (-> impl-ast
                   (replace-bound-vars {})
                   (inline-expr (cons dispatch-val arg-asts)))]
      expr)))


(defn inline-flat-map [name args]
  (let [num-args (count args)]
    (for [_ (sm/when (and (= 2 num-args)
                          (or (= 'flat-map name)
                              (= 'map name))))
          :let [[dispatch-ast f-ast] args]
          dispatch-val (emit dispatch-ast)
          impl-ast (map (get-proto-impl name num-args (.type-num dispatch-val))
                        .ast)
          :let [impl-ast (replace-bound-vars impl-ast {})
                [dispatch-sym f-sym] (.fixed (.params impl-ast))]
          body-exprs (traverse (.body impl-ast)
                               (fn [ast]
                                 (replace-syms ast {f-sym f-ast})))]
      (ast/let-ast (list (ast/binding dispatch-sym dispatch-val))
                   body-exprs))))

(extend-type rdr/tagged-symbol
  Emitter
  (bind [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg (c-code arg-var [] [] UnknownType {arg-var 1})]
          _ (comp (redef-proto-fn-error binding)
                  (sm/assoc-in-val [.fn-context .syms binding] arg))]
      (ParamBinding [arg-var] [])))

  (bind [binding evalled]
    (for [arg-var (genlocal binding "arg")
          :let [evalled (-> evalled
                            (.c-var arg-var)
                            (.init [(.init evalled) "Value *" arg-var " = "
                                    (.c-var evalled) ";" line-sep]))
                evalled-ref (c-code (.c-var evalled) [] [] (.type-num evalled)
                                    {(.c-var evalled) 1})]
          _ (comp (redef-proto-fn-error binding)
                  (sm/assoc-in-val [.fn-context .syms binding] evalled-ref))]
      (either (and (empty? (.init evalled))
                   (maybe (ParamBinding [(.c-var evalled)] [evalled])))
              (ParamBinding [(.c-var evalled)]
                            [evalled (c-init (.c-var evalled) [] []
                                             (.type-num evalled) {})]))))

  (emit [sym]
    (lookup-sym sym))

  (emit-defined-value [sym defined-sym]
    (for [value (lookup-sym sym)
          _ (debug 'defined-tagged defined-sym)
          _ (new-module-def defined-sym value)]
      [(make-c-code value)]))

  (tail-call [ast params] (TailExpr ast params))

  (emit-call-expr [target-ast args]
    (comp (call-vector target-ast args)
          (call-list target-ast args)
          (call-proto-impl target-ast args)))

  (replace-syms [ast subs]
    (sm/state-maybe (get subs ast ast)))

  (inline-expr [name arg-asts]
    (let [args (filter arg-asts produces-code?)]
      (comp (inline-wrap-and-apply* name args)
            (inline-flat-map name args))))

  (replace-bound-vars [ast subs]
    (get subs ast ast)))


(extend-type Symbol
  Emitter
  (bind [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg (c-code arg-var [] [] UnknownType {arg-var 1})]
          _ (comp (redef-proto-fn-error binding)
                  (sm/assoc-in-val [.fn-context .syms binding] arg))]
      (ParamBinding [arg-var] [])))

  (bind [binding evalled]
    (for [arg-var (genlocal binding "arg")
          :let [evalled (-> evalled
                            (.c-var arg-var)
                            (.init [(.init evalled) "Value *" arg-var " = "
                                    (.c-var evalled) ";" line-sep]))
                evalled-ref (c-code (.c-var evalled) [] [] (.type-num evalled)
                                    {(.c-var evalled) 1})]
          _ (comp (redef-proto-fn-error binding)
                  (sm/assoc-in-val [.fn-context .syms binding] evalled-ref))]
      (either (and (empty? (.init evalled))
                   (maybe (ParamBinding [(.c-var evalled)] [evalled])))
              (ParamBinding [(.c-var evalled)]
                            [evalled (c-init (.c-var evalled) [] []
                                             (.type-num evalled) {})]))))

  (emit [sym]
    (lookup-sym sym))

  (replace-syms [ast subs]
    (sm/state-maybe (get subs ast ast)))

  (inline-expr [name arg-asts]
    (let [args (filter arg-asts produces-code?)]
      (comp (inline-wrap-and-apply* name args)
            (inline-flat-map name args))))

  (replace-bound-vars [ast subs]
    (get subs ast ast)))


(defn get-type-number [type-symbol]
  (comp (for [type-symbol (sm/when type-symbol)
              ns-path (sym-ns-path type-symbol)
              type-num (comp (sm/get-in-val [.modules ns-path .types type-symbol])
                             (sm/get-in-val [.modules 'core .types type-symbol]))]
          type-num)
        (sm/state-maybe 0)))

(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))]
      (c-code "" [(.txt ast)] [] type-num {})))

  (emit-defined-value [ast defined-sym]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))
          c-var (comp (map (lookup-declaration defined-sym) .c-var)
                      (global-var defined-sym "var"))
          _ (new-module-def defined-sym (c-code c-var [] [] type-num {}))]
      [(c-code "" [] ["Value *" c-var " = " (.txt ast) ";" line-sep] type-num {})]))

  (emit-definition [ast]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))]
      [(c-code "" [] [(.txt ast)] type-num {})]))

  (tail-call [ast params] ast)

  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (for [evalled (traverse (.value ast) (fn [ast]
                                             (emit-defined-value ast defined-sym)))]
        (flatten evalled)))))

(extend-type ast/declaration-ast
  Emitter
  (emit-definition [ast]
    (let [sym (.sym ast)]
      (comp (map (lookup-declaration sym) (fn [_] []))
            (for [c-var (global-var sym "var")
                  :let [c-info (c-code c-var [] [] UnknownType {})]
                  _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym]
                                     (maybe c-info))]
              (let [c-info (.c-var c-info "")]
                [(.decl c-info ["Value *" c-var ";\n"])]))))))


;; optimize calls to static, fixed arity, functions
(defn call-static-fixed [target arg-vars ast]
  (for [arity-info (lookup-static-arity (.c-var target) (count arg-vars))
        result-sym (genlocal "rslt")
        line (line-macro ast "// static-fixed")]
    (c-init result-sym
            [line "Value *" result-sym " = " (.c-var arity-info) "("
             (interpose (cons "empty_list" (seq arg-vars)) ", ") ");" line-sep]
            [] (.type-num arity-info) {})))

(defn call-static-variadic [target arg-vars ast]
  (for [arity-info (lookup-static-arity (.c-var target) 'variadic)
        variadic-sym (genlocal "varArgs")
        result-sym (genlocal "rslt")
        line (line-macro ast "// static-variadic")]
    (c-init result-sym
            [line "List *" variadic-sym " = empty_list;" line-sep
             (map (reverse arg-vars)
                  (fn [arg-sym]
                    (str variadic-sym " = (List *)listCons("
                         "(Value *)" arg-sym
                         ", " variadic-sym ");" line-sep)))
             "Value *" result-sym " = " (.c-var arity-info) "(empty_list, (Value *)"
             variadic-sym ");" line-sep]
            []
            (.type-num arity-info)
            {})))

(defn call-dyn-fn-value [target args ast]
  (for [arity-sym (genlocal "arity")
        :when (= FunctionType (.type-num target))
        variadic-sym (genlocal "dynArgs")
        fn-var (genlocal "fn")
        result-sym (genlocal "rslt")
        line (line-macro ast "// dynamic fn type")]
    (let [arg-syms (conj args (str arity-sym "->closures"))
          num-args (count args)]
      (c-init result-sym
              ["Value *" result-sym ";" line-sep
               "FnArity *" arity-sym " = findFnArity(" (.c-var target)
               ", " num-args ");" line-sep
               "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) { "
               "FnType" num-args " *" fn-var " = (FnType" num-args " *)"
               arity-sym "->fn;" line-sep
               "\n" line
               result-sym " = " fn-var "(" (to-str (interpose arg-syms ", ")) ");" line-sep
               "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) { "
               "FnType1 *" fn-var " = (FnType1 *)" arity-sym "->fn;" line-sep
               "List *" variadic-sym " = empty_list;" line-sep
               (map (reverse (rest arg-syms))
                    (fn [arg-sym]
                      (str variadic-sym " = (List *)listCons("
                           arg-sym ", " variadic-sym ");" line-sep)))
               line result-sym " = " fn-var "(" (str arity-sym) "->closures, (Value *)"
               variadic-sym ");" line-sep
               "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s' at: %s, %d.\\n\", "
               "((Function *)" (.c-var target) ")->name, \"" (ast/file-name ast)
               "\", " (ast/line-number ast) ");\n  abort();\n}\n"
               "dec_and_free("(.c-var target) ", 1);" line-sep]
              []
              UnknownType {}))))

(def invoke-sym (rdr/tag 'invoke))
(def Type-sym (rdr/tag 'Type))
(def Function-sym (rdr/tag 'Function))
(def Stringable-sym (rdr/tag 'Stringable))
(def type-name-sym (rdr/tag 'type-name))
(def =*-sym (rdr/tag '=*))
(def get-type-sym (rdr/tag 'get-type))
(def extract-sym (rdr/tag 'extract))
(def instance?-sym (rdr/tag 'instance?))
(def new-type-value-sym (rdr/tag 'new-type-value))
(def string-list-sym (rdr/tag 'string-list))
(def list-sym (rdr/tag 'list))
(def has-field-sym (rdr/tag 'has-field))
(def identical-sym (rdr/tag 'identical))
(def Eq-sym (rdr/tag 'Eq))
(def Associative-sym (rdr/tag 'Associative))
(def get-sym (rdr/tag 'get))
(def maybe-sym (rdr/tag 'maybe))
(def HashMapNode-sym (rdr/tag 'HashMapNode))
(def assoc*-sym (rdr/tag 'assoc*))
(def make-value-sym (rdr/tag 'make-value))
(def store-sym (rdr/tag 'store))
(def reified-type-args-sym (rdr/tag 'reified-type-args))
(def nth-sym (rdr/tag 'nth))

(defn call-dyn-unknown-type [target args ast]
  (let [num-args (count args)]
    (for [arity-sym (genlocal "arity")
          variadic-sym (genlocal "dynArgs")
          fn-sym (genlocal "fn")
          result-sym (genlocal "rslt")
          invoke-arity-sym (map (lookup-core-fn-arity invoke-sym (inc num-args))
                                .c-var)
          line (line-macro ast "// dynamic unknown type")]
      (let [arg-syms (conj args (str arity-sym "->closures"))]
        (c-init result-sym
                [line "Value *" result-sym ";" line-sep
                 "if((" (.c-var target) ")->type != FunctionType) {" line-sep

                 result-sym " = " invoke-arity-sym "(empty_list, "
                 (to-str (interpose (conj args (.c-var target)) ", "))
                 ");" line-sep "} else {" line-sep

                 "FnArity *" arity-sym " = findFnArity(" (.c-var target) ", " num-args ");" line-sep
                 "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) {" line-sep
                 "FnType" num-args " *" fn-sym " = (FnType" num-args " *)" arity-sym "->fn;" line-sep
                 result-sym " = " fn-sym "(" (to-str (interpose arg-syms ", ")) ");" line-sep
                 "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) {" line-sep
                 "FnType1 *" fn-sym " = (FnType1 *)" arity-sym "->fn;" line-sep
                 "List *" variadic-sym " = empty_list;" line-sep
                 (map (reverse (rest arg-syms))
                      (fn [arg-sym]
                        (str variadic-sym " = (List *)listCons("
                             arg-sym ", " variadic-sym ");" line-sep)))
                 result-sym " = " fn-sym "(" (str arity-sym) "->closures, (Value *)"
                 variadic-sym ");" line-sep
                 "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                 "((Function *)" (.c-var target) ")->name"
                 ");" line-sep "  abort();" line-sep "}" line-sep
                 "dec_and_free("(.c-var target) ", 1);" line-sep "}" line-sep]
                [] UnknownType {})))))

(defn call-invoke [target args ast]
  (let [num-args (inc (count args))]
    (for [invoke-info (get-proto-impl invoke-sym num-args (.type-num target))
          arity-info (lookup-static-arity (.c-var invoke-info) num-args)
          result-sym (genlocal "rslt")
          line (line-macro ast "// call invoke")]
      (c-init result-sym
              [line "Value *" result-sym " = " (.c-var arity-info) "("
               (interpose (conj (cons (.c-var target) args) "empty_list") ", ") ");" line-sep]
              []
              (.type-num arity-info)
              {}))))

(defn update-last [asts f]
  (either (empty? asts)
          (let [[tail & init] (-> asts
                                  (filter produces-code?)
                                  reverse)]
            (-> (f tail)
                (cons init)
                reverse))))

(defn make-bindings [params args]
  (map (zip-lists (seq params) (seq args))
       (fn [[param val]]
         (ast/binding-ast param val))))


(extend-type ast/call-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          ast (extract (update-in ast [.call-target]
                                  (fn [target-ast]
                                    ((instance? Symbol target-ast)
                                     (rdr/tag target-ast)
                                     target-ast))))]
      (comp (for [new-ast (inline-expr (.call-target ast) (.args ast))
                  call-site (emit new-ast)]
              (c-init (.c-var call-site) (.init call-site) (.decl call-site)
                      (.type-num call-site) (.refs-map call-site)))
            (for [args (-> (.args ast)
                           (filter produces-code?)
                           emit)
                  call-site (comp (emit-call-expr (.call-target ast) args)
                                  (for [target (emit (.call-target ast))
                                        :let [arg-vars (map args .c-var)]
                                        call-site (comp (call-static-fixed target arg-vars ast)
                                                        (call-static-variadic target arg-vars ast)
                                                        (call-invoke target arg-vars ast)
                                                        (call-dyn-fn-value target arg-vars ast)
                                                        (call-dyn-unknown-type target arg-vars ast))]
                                    (comp* empty-c-code (comp args [target call-site])))
                                  (compilation-error "Could not compile call site at:"
                                                     file-name line-number))]
              (c-init (.c-var call-site) (.init call-site) (.decl call-site)
                      (.type-num call-site) (.refs-map call-site))))))

  (emit-defined-value [fn-val defined-sym]
    (for [init-fn-context (sm/get-in-val [.init .fn-context])
          fn-context (reset-fn-context init-fn-context)
          value (emit fn-val)
          var (comp (map (lookup-declaration defined-sym) .c-var)
                    (global-var defined-sym "var"))
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.init .fn-context] init-fn-context)
          _ (new-module-def defined-sym (c-code var [] [] (.type-num value) {}))]
      [(c-init var [(.init value)
                    var " = " (.c-var value) ";" line-sep
                    var "->refs = -1;" line-sep]
               [(.decl value) "Value *" var ";\n"]
               (.type-num value) (.refs-map value))]))
  
  (tail-call [ast params] (TailExpr ast params))

  (replace-syms [ast subs]
    (for [target (replace-syms (.call-target ast) subs)
          args (traverse (.args ast) (fn [ast]
                                       (replace-syms ast subs)))]
      (ast/call-ast target args)))

  (inline-expr [ast arg-asts]
    ;; TODO: remove the hard-coded check for 'new-sm
    (comp (for [_ (sm/when (= 'new-sm (.call-target ast)))
                f-ast (sm/when (first (.args ast)))
                new-ast (inline-expr f-ast arg-asts)]
            new-ast)
          (for [new-call-target (inline-expr (.call-target ast) (.args ast))
                new-ast (inline-expr new-call-target arg-asts)]
            new-ast)))
  
  (replace-bound-vars [ast subs]
    (ast/call-ast (replace-bound-vars (.call-target ast) subs)
                  (map (.args ast) (fn [ast]
                                     (replace-bound-vars ast subs))))))

(defn unpack-arg-list [list-sym elem-vars file-name line-num]
  (comp (sm/when (for [elem (first elem-vars)
                       :when (= 1 (count elem-vars))
                       var (first (.vars elem))]
                   (ParamBinding [list-sym]
                                 [(c-init var ["Value *" var " = (Value *)" list-sym ";" line-sep]
                                          [] ListType {})])))
        (for [destructArgs (genlocal "destArgs")]
          (let [elem-c-vars (flat-map elem-vars .vars)
                tail-var (extract (last elem-c-vars))
                elem-count (count elem-vars)]
            (ParamBinding [list-sym]
                          (comp [(c-code ""
                                         [(map elem-c-vars (fn [var] ["Value *" var ";" line-sep]))
                                          "Value **" destructArgs "[" elem-count "] = {"
                                          (interpose (map elem-c-vars (fn [arg] ["&" arg])) ", ")
                                          "};" line-sep "destructValue(\"" file-name "\", \"" line-num
                                          "\", (Value *)" list-sym ", " elem-count ", "
                                          destructArgs ");" line-sep]
                                         [] UnknownType {list-sym 1})]
                                (map elem-c-vars (fn [var]
                                                   (c-init var [] []
                                                           ((= var tail-var) ListType UnknownType)
                                                           {})))
                                (flat-map elem-vars .destruct)))))))


(defprotocol AllSyms
  (all-symbols [ast] (list ast)))

(extend-type ast/params-ast
  AllSyms
  (all-symbols [params]
    (comp (flat-map (.fixed params) all-symbols)
          (either (map (.variadic params) all-symbols)
                  empty-list)))

  Emitter
  (bind [params]
    (for [fixed-vars (map (traverse (.fixed params) bind) vec)
          tail-var (bind (either (.variadic params)
                                 (symbol "#tail")))
          param-var (genlocal "arg")
          destruct (unpack-arg-list param-var (conj fixed-vars tail-var)
                                    (ast/file-name params)
                                    (ast/line-number params))]
      destruct))

  (bind [params evalled]
    (for [fixed-vars (map (traverse (.fixed params) bind) vec)
          tail-var (bind (either (.variadic params)
                                 (symbol "#tail")))
          destruct (unpack-arg-list (.c-var evalled) (conj fixed-vars tail-var)
                                    (ast/file-name params) (ast/line-number params))]
      (.vars (either (and (empty? (.init evalled))
                          (empty? (.decl evalled))
                          (maybe destruct))
                     (.destruct destruct
                                (comp [evalled] (.destruct destruct))))
             [(.c-var evalled)])))

  (replace-bound-vars [ast subs]
    (let [new-fixed (map (.fixed ast) (fn [param]
                                        (replace-bound-vars param subs)))]
      (ast/params-ast new-fixed (map (.variadic ast) (fn [v]
                                                       (replace-bound-vars v subs)))))))


(extend-type ast/binding-ast
  Emitter
  (emit [ast]
    (flat-map (emit (.val ast))
              (partial bind (.binding ast)))))

(extend-type ast/let-ast
  Emitter
  (emit [ast]
    (for [locals (sm/get-in-val [.fn-context .syms])
          bindings (emit (.bindings ast))
          body-exprs (emit (.body ast))
          _ (sm/assoc-in-val [.fn-context .syms] locals)]
      (let [code (collapse-expressions (comp (flat-map bindings .destruct) body-exprs))]
        (c-init (.c-var code) (.init code) (.decl code) (.type-num code) (.refs-map code)))))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-in-val [.init .fn-context])
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          var (comp (map (lookup-declaration defined-sym) .c-var)
                    (global-var defined-sym "var"))
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.init .fn-context] init-fn-context)
          _ (new-module-def defined-sym (c-code var [] [] (.type-num value) {}))]
      [(c-init var [(.init value)
                    var " = " (.c-var value) ";" line-sep
                    var "->refs = -1;" line-sep]
               [(.decl value) "Value *" var ";\n"]
               (.type-num value) (.refs-map value))]))

  (tail-call [ast params]
    (.body ast (-> ast
                   .body
                   (tail-call params))))

  (replace-syms [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (comp (for [binding-ast (sm/when (first bindings))
                          new-val (replace-syms (.val binding-ast) subs)
                          :let [new-subs (reduce (all-symbols (.binding binding-ast))
                                                 subs dissoc)]
                          new-bindings (recur (rest bindings) new-bindings new-subs)]
                      (conj new-bindings (.val binding-ast new-val)))
                    (sm/state-maybe new-bindings)))]
      (for [new-bindings (f (.bindings ast) [] subs)
            new-body (traverse (.body ast) (fn [ast]
                                             (replace-syms ast subs)))]
        (ast/let-ast (seq new-bindings) new-body))))

  (inline-expr [ast arg-asts]
    (let [unique-syms (map arg-asts (fn [_] (gensym "#arg")))]
      (-> ast
          (.bindings (comp (make-bindings unique-syms arg-asts)
                           (.bindings ast)))
          (.body (update-last (.body ast) (fn [ast]
                                            (ast/call-ast ast unique-syms))))
          (sm/state-maybe))))

  (replace-bound-vars [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (either (for [binding-ast (first bindings)]
                        (let [new-val (replace-bound-vars (.val binding-ast) subs)
                              new-subs (reduce (all-symbols (.binding binding-ast))
                                               subs (fn [new-subs sym]
                                                      (assoc new-subs sym (symbol (str "#" sym)))))
                              [new-bindings new-subs] (recur (rest bindings) new-bindings new-subs)]
                          [(conj new-bindings
                                 (ast/binding-ast (replace-bound-vars (.binding binding-ast)
                                                                      new-subs)
                                                  new-val))
                           new-subs]))
                      [new-bindings subs]))]
      (let [[new-bindings new-subs] (f (.bindings ast) empty-list subs)
            new-body (map (.body ast) (fn [ast]
                                        (replace-bound-vars ast new-subs)))]
        (ast/let-ast (seq new-bindings) new-body)))))


(defn index [coll]
  (let [coll (seq coll)]
    (zip-lists (range (count coll)) coll)))

(defn closure-reified-value [type-num impl-fns]
  ;; TODO: change impls-fns to be a list of StaticArity/ClosureArity
  (let [inits (map impl-fns .init)]
    (for [reified-sym (genlocal "reifiedDyn")
          :when-not (every inits empty?)]
      (let [impls-syms (map impl-fns .c-var)]
        (c-init reified-sym
                [inits
                 ["Value *" reified-sym " = (Value *)malloc_reified("
                  (count impls-syms) ");" line-sep
                  "((ReifiedVal *)" reified-sym ")->type = " type-num ";" line-sep
                  "((ReifiedVal *)" reified-sym ")->implCount = "
                  (count impl-fns) ";" line-sep
                  "((ReifiedVal *)" reified-sym ")->typeArgs = (Value *)0;" line-sep]
                 (flat-map (index impls-syms)
                           (fn [[index sym]]
                             ["((ReifiedVal *)" reified-sym
                              ")->impls[" index "] = (Value *)" sym ";" line-sep]))]
                (map impl-fns .decl)
                type-num
                (apply merge-with + (map impl-fns .refs-map)))))))

(defn static-reified-value [type-num impl-fns]
  (for [reified-sym (global-var "reifiedStatic")
        reified-ptr (global-var "reifiedPtr")]
    (c-code reified-ptr
            []
            [(map impl-fns .decl)
             "ReifiedVal " reified-sym " = {"
             type-num ", -1, (Value *)0, 0, {}};" line-sep
             "Value *" reified-ptr " = (Value *)&" reified-sym ";" line-sep]
            type-num {})))

(defprotocol ArityType
  (closure-arity? [_] nothing)
  (reify-arity [_ dispatch-type-num arity-ast fn-name]))

(deftype StaticArity [arity-fn-var param-count return-type var-info]
  Stringable
  (string-list [_]
    (comp (list "<StaticArity " (str arity-fn-var) " " (str param-count) " "
                (target-type-name return-type) " ")
          (string-list var-info)))

  ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name]
    (for [_ (new-proto-impl fn-name param-count dispatch-type-num var-info arity-ast)
          _ (new-static-arity (.c-var var-info) param-count arity-fn-var return-type)]
      var-info)))

(deftype ClosureArity [arity-fn-var params var-info]
  Stringable
  (string-list [_]
    (comp (list "<ClosureArity " (str arity-fn-var) " " (str params) " ")
          (string-list var-info)))

  ArityType
  (closure-arity? [arity] (maybe arity))
  (reify-arity [_ dispatch-type-num arity-ast fn-name]
    (let [param-count (count params)
          fn-arity-sym (gensym "protoFnArity")
          impl-fn-sym (gensym "protoImpl")]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            [dispArg & args] (traverse (.fixed params) (fn [arg] (genlocal arg "arg")))
            :let [arg-decls (to-str (interpose (conj (map (cons dispArg args)
                                                          (fn [arg] (str "Value *" arg)))
                                                     (str "List *closures"))
                                               ", "))
                  args (to-str (interpose (comp ["closures" dispArg] args) ", "))]
            _ (new-proto-impl fn-name param-count dispatch-type-num
                              (c-code (str "&" fn-arity-sym) [] [] FunctionType {}) arity-ast)
            _ (sm/update-in-val [.reify-fn-index] inc)]
        (let [reified-fn (c-code "" []
                                 ["// implementation of " fn-name "\n"
                                  "Value *" impl-fn-sym "(" arg-decls ") {" line-sep
                                  "FnArity *arityPtr = (FnArity *)((ReifiedVal *)" dispArg 
                                  ")->impls["
                                  reify-fn-index "];" line-sep
                                  "incRef(" dispArg ", 1);" line-sep
                                  "Value *rval = ((FnType" param-count
                                  " *)arityPtr->fn)(arityPtr->" args ");" line-sep
                                  "dec_and_free(" dispArg ", 1);" line-sep
                                  "return(rval);" line-sep
                                  "};\n\n"
                                  "FnArity " fn-arity-sym " = {FnArityType, -1, " param-count
                                  ", (List *)0, 0, " impl-fn-sym "};" line-sep]
                                 UnknownType {})]
          (comp reified-fn var-info))))))

(defn emit-closures []
  (comp (for [closures (sm/get-in-val [.fn-context .closed-over .closures])
              :when-not (empty? closures)
              :let [closures (comp (reverse closures) [["closuresTail" ""]])]
              destructArgs (genlocal "destArgs")]
          (cons (c-code ""
                        [(map closures (fn [[arg]] ["Value *" arg ";" line-sep]))
                         "incRef((Value *)closures, 1);" line-sep
                         "Value **" destructArgs "[" (count closures) "] = {"
                         (interpose (map closures (fn [[arg]] ["&" arg])) ", ") "};" line-sep
                         "destructValue(\"\", \"\", (Value *)closures"
                         ", " (count closures) ", " destructArgs ");" line-sep]
                        []
                        UnknownType {})
                (map closures (fn [[arg]] (c-init arg [] [] UnknownType {})))))
        (sm/state-maybe [])))

(defn closures-init [closures arity-sym]
  (for [_ (sm/when-not (empty? closures))
        closure-vars (traverse closures (fn [[_ sym]] (lookup-sym sym)))]
    (map closure-vars
         (fn [closure]
           (c-code arity-sym
                   [arity-sym "->closures = listCons((Value *)"
                    (.c-var closure) ", (List *)" arity-sym "->closures);" line-sep]
                   []
                   ListType
                   {(.c-var closure) 1})))))

(defn set-type [sym type-num]
  (comp (for [sym-info (sm/get-in-val [.fn-context .syms sym])
              _ (sm/assoc-in-val [.fn-context .syms sym .type-num] type-num)]
          "")
        sm-space))

;; TODO: revisit this, (obviously)
(defn emit-fn-arity
  ([fn-sym fn-var params param-types body]
   (flat-map (global-var fn-sym "arityImpl")
             (fn [arity-fn-var]
               (emit-fn-arity fn-sym fn-var params param-types body arity-fn-var))))
  ([fn-sym fn-var params param-types body arity-fn-var]
   (let [arity-index ((.variadic params) 'variadic (count params))]
     (for [_ (sm/when (some body produces-code?))
           fn-context (reset-fn-context)
           _ (comp (sm/get-in-val [.fn-context .syms fn-sym])
                   (sm/assoc-in-val [.fn-context .syms fn-sym]
                                    (c-code fn-var [] [] FunctionType {})))
           _ (comp (sm/when (= 'variadic arity-index))
                   ;; TODO: make this UnknownType be IgnoreType
                   (sm/assoc-in-val [.fn-context .recurse fn-var arity-index]
                                    (c-code arity-fn-var [] [] UnknownType {})))
           param-vars (comp (for [tail (sm/when (.variadic params))
                                  fixed-vars (map (traverse (.fixed params) bind) vec)
                                  tail-var (bind tail)
                                  _ (sm/assoc-in-val [.fn-context .syms tail .type-num] ListType)
                                  param-var (genlocal "arg")
                                  destruct (unpack-arg-list param-var (conj fixed-vars tail-var)
                                                            (ast/file-name params)
                                                            (ast/line-number params))]
                              destruct)
                            (for [vars (traverse (.fixed params) bind)
                                  :when-not (empty? vars)]
                              (let [inline-body? (some body (partial instance? ast/inline-ast))
                                    param-vars (apply comp vars)
                                    param-destruct (either (and inline-body? (maybe []))
                                                           (comp (map (.vars param-vars)
                                                                      (fn [var]
                                                                        (c-init var [] []
                                                                                UnknownType
                                                                                {})))
                                                                 (.destruct param-vars)))]
                                (ParamBinding (.vars param-vars) param-destruct)))
                            (sm/state-maybe (ParamBinding [] [])))
           _ (traverse (zip-lists (seq (.fixed params)) (seq param-types))
                       (fn [[var type-num]] (set-type var type-num)))
           body-exprs (-> body
                          (tail-call (.vars param-vars))
                          emit)
           destruct-closures (emit-closures)
           :let [exprs (comp (.destruct param-vars)
                             destruct-closures
                             body-exprs)
                 body (collapse-expressions exprs)]
           closures (sm/get-in-val [.fn-context .closed-over .closures])
           _ (reset-fn-context fn-context)
           :let [param-decls (seq (map (.vars param-vars) (fn [param]
                                                            (str "Value *" param))))
                 fn-expr (c-code "" []
                                 ["Value *" arity-fn-var "("
                                  (interpose (cons "List *closures" param-decls) ", ")
                                  ") {\n"]
                                 FnArityType {})
                 fn-result (either (and (= "" (.c-var body))
                                        (maybe "nothing"))
                                   (.c-var body))
                 arg-count (count (.vars param-vars))]
           arity-info (comp (for [arity-var (genlocal fn-sym "dynArity")
                                  closed-over (closures-init closures arity-var)
                                  closure-vars (traverse closures
                                                         (fn [[_ sym]]
                                                           (lookup-sym sym)))]
                              (ClosureArity arity-fn-var params
                                            (comp* (c-init arity-var
                                                           ["FnArity *" arity-var
                                                            " = malloc_fnArity();" line-sep

                                                            arity-var "->count = " arg-count ";" line-sep
                                                            arity-var "->variadic = "
                                                            ((.variadic params) "1" "0") ";" line-sep
                                                            arity-var "->fn = " arity-fn-var ";" line-sep
                                                            arity-var "->closures = empty_list;" line-sep]
                                                           [(.decl body)
                                                            (.decl fn-expr)
                                                            (.init fn-expr)
                                                            "while (1) {\n"
                                                            (.init body)
                                                            line-sep "};};\n"]
                                                           FnArityType {})
                                                   closed-over)))
                            (for [arity-var (comp (for [dispatch-type (sm/when (first param-types))
                                                        proto-impl (get-proto-impl fn-sym
                                                                                   arity-index
                                                                                   dispatch-type)]
                                                    (.c-var proto-impl))
                                                  (global-var fn-sym "staticArity"))]
                              (StaticArity arity-fn-var arity-index (.type-num body)
                                           (c-code (str "&" arity-var)
                                                   []
                                                   [(.decl body)
                                                    (.decl fn-expr)
                                                    (.init fn-expr)
                                                    " while (1) {\n"
                                                    (.init body)
                                                    line-sep "};};"
                                                    "\nFnArity " arity-var " = {FnArityType, -1, "
                                                    arg-count
                                                    ", (List *)0, " ((.variadic params) "1" "0")
                                                    ", " arity-fn-var "};" line-sep]
                                                   FnArityType {}))))]
       arity-info))))

(defn validate-protocol-names [ast]
  (traverse (keys (.impls ast))
            (fn [protocol-name]
              (comp (get-protocol protocol-name)
                    (compilation-error "Invalid protocol:" protocol-name "in"
                                       (str (ast/file-name ast) ",")
                                       (ast/line-number protocol-name))))))

(defn validate-proto-fn-name [fn-name arg-count]
  (comp (get-protocol-dispatcher fn-name arg-count)
        (compilation-error "Invalid protocol fn:"
                           (str "'" fn-name "' in")
                           (str (ast/file-name fn-name) ",")
                           (ast/line-number fn-name))))

(deftype ProtoImplDeclaration [fn-name arity-ast arity-impl-var c-decl])

(defn declare-impl [type-str type-num [fn-name arity-ast]]
  (let [num-args (count (.params arity-ast))]
    (for [_ (validate-proto-fn-name fn-name num-args)
          impl-fn-var (global-var fn-name "staticArity")
          arity-impl-var (global-var (str type-str fn-name) "arityImpl")
          _ (new-proto-impl fn-name num-args type-num
                            (c-code impl-fn-var [] [] UnknownType {})
                            arity-ast)
          _ (new-static-arity impl-fn-var num-args arity-impl-var UnknownType)]
      (ProtoImplDeclaration fn-name arity-ast arity-impl-var
                            ["Value *" arity-impl-var "("
                             (interpose (cons "List *closures"
                                              (seq (map (-> arity-ast .params .fixed)
                                                        (fn [param]
                                                          (str "Value *")))))
                                        ", ")
                             ");\n"]))))

(defn emit-impl [type-str type-num impl-decl]
  (let [[fn-name arity-ast arity-var] (type-args impl-decl)
        num-args (count (.params arity-ast))]
    (for [ext-fn (comp (emit-fn-arity (str type-str fn-name) (.fn-var arity-ast)
                                      (.params arity-ast) [type-num] (.body arity-ast) arity-var)
                       (compilation-error "Could not compile protocol fn:"
                                          (str "'" fn-name "' in")
                                          (str (ast/file-name fn-name) ",")
                                          (ast/line-number fn-name)))
          reified (reify-arity ext-fn type-num arity-ast fn-name)]
      reified)))

(defn extend-type* [ast type-num]
  (let [impl-arities (for [impl-fns (vals (.impls ast))
                            [fn-name arities] (seq impl-fns)
                            impl-arity arities]
                        [fn-name impl-arity])]
    (comp (sm/when (empty? impl-arities))
          (for [type-str (comp (map (sm/get-in-val [.constants .type-names type-num])
                                    (fn [type]
                                      (str type "_")))
                               (sm/state-maybe ""))
                _ (validate-protocol-names ast)
                impl-arities (traverse impl-arities (partial declare-impl type-str type-num))
                [head-fn & fns] (traverse impl-arities (partial emit-impl type-str type-num))]
            (cons (.decl head-fn [(map impl-arities .c-decl) (.decl head-fn)])
                  fns)))))

(extend-type ast/reify-ast
  Emitter
  (emit [ast]
    (let [reified-type-num (.type-num ast)]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            _ (sm/set-val .reify-fn-index 0)
            impl-fns (extend-type* ast reified-type-num)
            _ (sm/set-val .reify-fn-index reify-fn-index)
            reified-result (comp (closure-reified-value reified-type-num impl-fns)
                                 (static-reified-value reified-type-num impl-fns))]
        reified-result)))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-in-val [.init .fn-context])
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.init .fn-context] init-fn-context)
          value (comp (map (lookup-declaration defined-sym)
                           (fn [c-info]
                             (c-code (.c-var value) [(.init value) "\n" (.c-var c-info) " = "
                                                     (.c-var value) ";" line-sep]
                                     (.decl value) (.type-num value) (.refs-map value))))
                      (sm/state-maybe value))
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] (.type-num value) {}))]
      [value]))

  (tail-call [ast params] (TailExpr ast params)))


(defn filter-vals [m f]
  (reduce (seq m) {}
          (fn [m [k v]]
            (either (map (f v) (fn [_] (assoc m k v)))
                    m))))

(defn decrement-refs [refs-map [var var-refs]]
  (either (update-in refs-map [var] (fn [refs]
                                      (- refs var-refs)))
          refs-map))

(defn cond-clause-init [cond-test expr-result [init refs-map] clause]
  (let [refs-map (-> (.refs-map clause)
                     seq
                     (reduce refs-map decrement-refs)
                     (filter-vals (partial < 0)))]
    [(conj (vec init)
           [(.init clause)
            expr-result " = " (.c-var clause) ";" line-sep
            cond-test expr-result ")) {" line-sep
            (map (seq refs-map) (fn [[c-sym remaining]]
                                  ["dec_and_free(" c-sym ", " remaining ");" line-sep]))])
     refs-map]))

(defn emit-cond-expr [result-var clauses cond-test tail-return]
    (for [evalled-clauses (-> clauses
                              (filter produces-code?)
                              emit)
          last-clause (sm/when (last evalled-clauses))]
      (let [clause-vars (-> evalled-clauses
                            (remove (fn [c] (empty? (.init c))))
                            (map .c-var)
                            set)
            refs-maps (map evalled-clauses .refs-map)
            refs-map (-> (apply merge-with + refs-maps)
                         (remove-keys clause-vars)
                         (filter-vals (partial < 0)))
            [clause-inits] (-> (butlast evalled-clauses)
                               (reduce [[] refs-map]
                                       (partial cond-clause-init cond-test result-var)))
            last-init ((= "" (.c-var last-clause))
                       (.init last-clause)
                       [(.init last-clause)
                        result-var " = " (.c-var last-clause) ";" line-sep])
            clause-inits (conj clause-inits last-init)]
        (c-init result-var
                ["Value *" result-var ";" line-sep
                 (interpose clause-inits [tail-return "} else {" line-sep
                                          "dec_and_free(" result-var ", 1);" line-sep])
                 (-> evalled-clauses
                     count
                     dec
                     (repeat (str "}" line-sep)))]
                (map evalled-clauses .decl)
                MaybeType refs-map))))

(deftype TailAnd [clauses]
  Stringable
  (string-list [expr]
    (comp (list "<TailAnd ") (flat-map clauses string-list) (list ">")))

  Emitter
  (emit [ast]
    (for [result-var (genlocal "andRslt")
          expr (emit-cond-expr result-var (.clauses ast) "if (isNothing("
                               (str "return(nothing);" line-sep))]
      expr)))


(extend-type ast/and-ast
  Emitter
  (emit [ast]
    (for [result-var (genlocal "andRslt")
          expr (emit-cond-expr result-var (.clauses ast) "if (isNothing(" "")]
      expr))

  (tail-call [ast params]
    (let [[last-clause & clauses] (reverse (seq (.clauses ast)))]
      (TailAnd (-> (tail-call last-clause params)
                   (cons clauses)
                   reverse))))

  (replace-syms [ast subs]
    (for [new-clauses (traverse (.clauses ast)
                                (fn [ast]
                                  (replace-syms ast subs)))]
      (.clauses ast new-clauses)))

  (replace-bound-vars [ast subs]
    (ast/and-ast (map (.clauses ast) (fn [ast]
                                       (replace-bound-vars ast subs))))))

(deftype TailOr [clauses]
  Stringable
  (string-list [expr]
    (comp (list "<TailOr ") (flat-map clauses string-list) (list ">")))

  Emitter
  (emit [ast]
    (for [result-var (genlocal "orRslt")
          expr (emit-cond-expr result-var (.clauses ast) "if (!isNothing("
                               (str "return(" result-var ");" line-sep))]
      expr)))

(extend-type ast/or-ast
  Emitter
  (emit [ast]
    (flat-map (genlocal "orRslt")
              (fn [result-var]
                (emit-cond-expr result-var (.clauses ast) "if (!isNothing(" line-sep))))

  (tail-call [ast params]
    (let [[last-clause & clauses] (reverse (seq (.clauses ast)))]
      (TailOr (-> (tail-call last-clause params)
                  (cons clauses)
                  reverse))))

  (replace-syms [ast subs]
    (for [new-clauses (traverse (.clauses ast)
                                (fn [ast]
                                  (replace-syms ast subs)))]
      (.clauses ast new-clauses)))

  (replace-bound-vars [ast subs]
    (ast/or-ast (map (.clauses ast) (fn [ast]
                                      (replace-bound-vars ast subs)))))) 

(deftype TailEither [clause alt]
  Emitter
  (emit [ast]
    (for [cond-val (emit (.clause ast))
          alt-val (emit (.alt ast))]
      (let [cond-rslt (.c-var cond-val)
            refs-map (-> (merge-with + (.refs-map cond-val)
                                     (.refs-map alt-val))
                         (filter-vals (partial < 0)))]
        (c-code ""
                [(.init cond-val)
                 "if (!isNothing(" cond-rslt ")) {" line-sep
                 (-> (.refs-map alt-val)
                     (filter-vals (partial < 0))
                     seq
                     (map (fn [[var refs]]
                            ["dec_and_free(" var ", " refs ");" line-sep])))
                 "return(maybeExtract(" cond-rslt "));" line-sep
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 "return(" (.c-var alt-val) ");" line-sep
                 "}" line-sep]
                (comp (.decl cond-val) (.decl alt-val))
                UnknownType
                refs-map)))))

(extend-type ast/either-ast
  Emitter
  (emit [ast]
    (for [result-var (genlocal "eitherRslt")
          cond-val (emit (.clause ast))
          alt-val (emit (.alt ast))]
      (let [cond-rslt (.c-var cond-val)
            refs-map (-> (merge-with + (.refs-map cond-val)
                                     (.refs-map alt-val))
                         (filter-vals (partial < 0)))]
        (c-init result-var
                [(.init cond-val)
                 "Value *" result-var ";" line-sep
                 "if (!isNothing(" cond-rslt ")) {" line-sep
                 (-> (.refs-map alt-val)
                     (filter-vals (partial < 0))
                     seq
                     (map (fn [[var refs]]
                            ["dec_and_free(" var ", " refs ");" line-sep])))
                 result-var " = maybeExtract(" cond-rslt ");" line-sep
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 result-var " = " (.c-var alt-val) ";" line-sep
                 "}" line-sep]
                (comp (.decl cond-val) (.decl alt-val))
                UnknownType
                refs-map))))

  (tail-call [ast params]
    (TailEither (.clause ast) (.alt ast)))

  (replace-syms [ast subs]
    (ast/either-ast (replace-syms (.clause ast) subs)
                    (replace-syms (.alt ast) subs)))

  (replace-bound-vars [ast subs]
    (ast/either-ast (replace-bound-vars (.clause ast) subs)
                    (replace-bound-vars (.alt ast) subs)))) 


(extend-type ast/assert-ast
  Emitter
  (produces-code? [ast] nothing)

  (emit [ast]
    (sm/state-maybe empty-c-code))

  (tail-call [ast params] ast))


(extend-type ast/returns-ast
  Emitter
  (produces-code? [ast] nothing)

  (emit [ast]
    (sm/state-maybe empty-c-code))

  (tail-call [ast params] ast))

(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [;; _ (debug 'main-fn)
          fn-arity (emit-fn-arity 'main "" (.params ast) [ListType] (.body ast))
          ;; _ (debug "=======")
          _ (new-static-arity 'main 1 (.arity-fn-var fn-arity) IntegerType)]
      [(c-code "" [] (.decl (.var-info fn-arity)) 0 {})])))


(defn declare-proto-dispatch-arity [fn-name dispatch-fn-var prototype]
  (let [num-args (count (.params prototype))]
    (for [arity-fn-var (global-var fn-name "protoDisp")
          impls-sym (global-var (str fn-name "_Implementations") "protoImpls")
          _ (new-proto-dispatcher fn-name num-args arity-fn-var impls-sym)
          _ (new-static-arity dispatch-fn-var num-args arity-fn-var UnknownType)]
      ["ProtoImpls " impls-sym ";\n"
       "Value *" arity-fn-var "("
       (interpose (conj (map (range num-args)
                             (fn [n]
                               (str "Value *arg" n)))
                        "List *closures")
                  ", ")
       ");\n"])))

(defn emit-proto-default [protocol-name fn-name prototype]
  (let [default-body (.default-body prototype)]
    (comp (for [_ (sm/when-not (empty? default-body))
                static-arity (emit-fn-arity (str "Default_" fn-name) ""
                                            (.params prototype) [] default-body)
                _ (new-proto-impl fn-name (count (.params prototype)) 0
                                  (.var-info static-arity) default-body)]
            (.decl (.var-info static-arity)))

          sm-space)))

(defn create-dispatcher [proto-name [fn-name arities]]
  (for [dispatch-fn-sym (global-var fn-name "dispatchFnPtr")
        _ (sm/assoc-in-val [.modules (ast/file-name fn-name) .values fn-name]
                           (c-code dispatch-fn-sym [] [] FunctionType {}))
        _ (new-protocol-fn fn-name dispatch-fn-sym)
        dispatch-arities (traverse arities
                                   (partial declare-proto-dispatch-arity
                                            fn-name dispatch-fn-sym))
        default-fns (traverse arities
                              (partial emit-proto-default proto-name fn-name))]
    ["\n// proto fn for " proto-name "/" fn-name "\n"
     "Value *" dispatch-fn-sym ";\n"
     dispatch-arities
     default-fns]))

(extend-type ast/protocol-ast
  Emitter
  (emit-definition [ast]
    (let [proto-name (.protocol-sym ast)
          prototype-map (apply merge-with comp
                               (map (.prototypes ast)
                                    (fn [prototype]
                                      {(.fn-name prototype) [prototype]})))]
      (for [_ (new-protocol proto-name)
            decl (traverse (seq prototype-map)
                        (partial create-dispatcher proto-name))]
        [(c-code "" [] decl UnknownType {})]))))


(extend-type ast/fn-arity-ast
  Emitter
  (emit [ast]
    (emit-fn-arity (.fn-sym ast) (.fn-var ast) (.params ast) (.param-types ast) (.body ast)))

  (inline-expr [ast arg-asts]
    (sm/state-maybe (ast/let-ast (make-bindings (.fixed (.params ast)) arg-asts)
                                 (.body ast))))

  (replace-syms [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs dissoc)]
      (for [new-body (traverse (.body ast) (fn [ast]
                                             (replace-syms ast subs)))]
        (.body ast new-body))))

  (replace-bound-vars [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs
                       (fn [subs sym]
                         (assoc subs sym (symbol (str "#" sym)))))]
      (-> ast
          (.params (replace-bound-vars (.params ast) subs))
          (.body (map (.body ast) (fn [ast]
                                    (replace-bound-vars ast subs))))))))


(defn static-fn [fn-sym fn-var arities]
  (for [struct-var (global-var fn-sym "fnStruct")
        emitted-arities (traverse arities
                                  (fn [static-arity]
                                    (for [_ (new-static-arity fn-var
                                                              (.param-count static-arity)
                                                              (.arity-fn-var static-arity)
                                                              (.return-type static-arity))]
                                      (.var-info static-arity))))]
    (let [arity-count (count emitted-arities)]
      (c-code fn-var []
              ["\n// --------- " fn-sym " -------------\n"
               "Value *" fn-var ";\n"
               (map emitted-arities .decl)
               "Function " struct-var " = {FunctionType, -1, \""
               fn-sym "\", " arity-count ", "
               "{" (to-str (interpose (map emitted-arities .c-var)
                                      ", "))
               "}};\n"
               "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]
              FunctionType {}))))

(defn closure-fn [fn-sym fn-var arities]
  (for [_ (sm/when (some arities closure-arity?))
        struct-var (global-var fn-sym "fnStruct")
        line (line-macro fn-sym (str "//creating " fn-sym))]
    (let [arity-count (count arities)
          emitted-arities (map arities .var-info)]
      (c-code fn-var
              [(map emitted-arities .init)
               line "Function *" struct-var " = malloc_function(" arity-count ");" line-sep
               struct-var "->name = \"" fn-sym "\";" line-sep
               struct-var "->arityCount = " arity-count ";" line-sep
               (map (zip-lists (map emitted-arities .c-var)
                               (range arity-count))
                    (fn [[sym index]]
                      (str struct-var "->arities[" index "] = " sym ";" line-sep)))
               "Value *" fn-var " = (Value *)" struct-var ";" line-sep]
              [(map emitted-arities .decl)]
              FunctionType
              (apply merge-with + (map emitted-arities .refs-map))))))

(extend-type ast/fn-ast
  Emitter
  (emit [ast]
    (comp (for [fn-sym (sm/when (.fn-sym ast))
                ;; _ (debug 'fn-sym fn-sym)
                fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                             (global-var fn-sym "fn"))
                arities (emit (map (.arities ast) (fn [arity]
                                                    (-> arity
                                                        (.fn-sym fn-sym)
                                                        (.fn-var fn-var)))))
                fn-expr (comp (closure-fn fn-sym fn-var arities)
                              (static-fn fn-sym fn-var arities))
                ;; _ (debug "---------")
                ]
            fn-expr)
          (for [fn-var (global-var "fn")
                arities (emit (.arities ast))
                fn-expr (comp (closure-fn 'anon fn-var arities)
                              (static-fn 'anon fn-var arities))]
            fn-expr)))

  (emit-defined-value [fn-val defined-sym]
    (for [value (emit fn-val)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] FunctionType {}))]
      [(make-c-code value)]))

  (tail-call [x params] (TailExpr x params))

  (inline-expr [ast arg-asts]
    (for [arity (sm/when (-> (.arities ast)
                             (filter (fn [arity]
                                       (= (count arg-asts) (count (.params arity)))))
                             first))
          expr (inline-expr arity arg-asts)]
      expr))

  (replace-syms [ast subs]
    (for [new-arities (traverse (.arities ast)
                                (fn [arity]
                                  (replace-syms arity subs)))]
      (.arities ast new-arities)))

  (replace-bound-vars [ast subs]
    (.arities ast (map (.arities ast) (fn [arity]
                                        (replace-bound-vars arity subs))))))

(extend-type ast/extend-ast
  Emitter
  (emit-definition [ast]
    (let [type-sym (.type ast)]
      (comp (for [type-nums (sm/when (or (and (= type-sym 'HashMap)
                                              (maybe (list BitmapIndexedType
                                                           ArrayNodeType
                                                           HashCollisionNodeType)))
                                         (and (= type-sym 'String)
                                              (maybe (list StringType
                                                           SubStringType)))))
                  fns (map (traverse type-nums (partial extend-type* ast))
                           flatten)]
              fns)
            (for [ns-path (sym-ns-path (.type ast))
                  type-num (comp (sm/get-in-val [.modules ns-path .types type-sym])
                                 (sm/get-in-val [.modules 'core .types type-sym]))
                  fn (extend-type* ast type-num)]
              fn)
            (compilation-error "Trying to extend unknown type: "
                               type-sym "at"
                               (str (.file-name (.type ast)) ":")
                               (ast/line-number (.type ast)))))))


(defn declare-getters [new-type-name fields]
  (traverse fields
            (fn [field]
              (let [getter-sym (rdr/tag (symbol (str "." field)) 'core 0)]
                (comp (map (sm/get-in-val [.modules 'core .proto-fns getter-sym]) (fn [_] []))
                      (for [dispatch-fn-var (global-var "dispatchFnPtr")
                            arity-fn-var1 (global-var "protoImpl")
                            impls-sym1 (global-var "protoImpls")
                            arity-fn-var2 (global-var "protoImpl")
                            impls-sym2 (global-var "protoImpls")
                            _ (new-module-def getter-sym (c-code dispatch-fn-var [] []
                                                                 FunctionType {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym]
                                               (ProtoFnInfo getter-sym dispatch-fn-var {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym]
                                               (ProtoFnInfo getter-sym dispatch-fn-var {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym .dispatchers 1]
                                               (ProtocolDispatcher 1 arity-fn-var1 impls-sym1 {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym .dispatchers 2]
                                               (ProtocolDispatcher 2 arity-fn-var2 impls-sym2 {}))
                            _ (new-static-arity dispatch-fn-var 1 arity-fn-var1 UnknownType)
                            _ (new-static-arity dispatch-fn-var 2 arity-fn-var2 UnknownType)]
                        ["ProtoImpls " impls-sym1 ";\n"
                         "ProtoImpls " impls-sym2 ";\n"
                         "Value *" dispatch-fn-var ";\n"
                         "Value *" arity-fn-var1
                         "(List *closures, Value *arg);\n"
                         "Value *" arity-fn-var2
                         "(List *closures, Value *arg1, Value *arg2);\n"]))))))

(defn constructor-expr [new-type-name type-val-sym fields]
  (ast/definition new-type-name
    [(ast/reified (extract rdr/type-counter)
                  {Type-sym
                   [[type-name-sym
                     [(ast/fn-arity-ast (str new-type-name "_const_type_name") ""
                                        (ast/params ['_]) "" []
                                        [(str "*" new-type-name " constructor*")])]]
                    [instance?-sym
                     [(ast/fn-arity-ast (str new-type-name "_instance_QMARK_") ""
                                        (ast/params ['x 'y]) "" []
                                        [(ast/call-ast =*-sym
                                                       [(ast/call-ast get-type-sym [type-val-sym])
                                                        (ast/call-ast get-type-sym ['y])])])]]]

                   Function-sym
                   [[invoke-sym
                     [(ast/fn-arity-ast (str new-type-name "_invoke") ""
                                        (ast/params (vec (cons '_ (seq fields)))) "" []
                                        [(ast/call-ast new-type-value-sym
                                                       [type-val-sym (ast/call-ast 'vector (seq fields))])])]]]

                   Stringable-sym
                   [[string-list-sym
                     [(ast/fn-arity (ast/params ['z]) ""
                                    [(ast/call-ast list-sym
                                                   ["<TypeCon " (str new-type-name) " ["
                                                    (to-str (interpose fields ", ")) "]>"])])]]]})]))

(defn type-val-expr [type-sym type-val-sym fields impls]
  (let [x* (symbol "#x")
        y* (symbol "#y")
        field* (symbol "#field")]
    (ast/definition type-val-sym
      [(ast/reified (extract rdr/type-counter)
                    (merge-with comp
                                {Type-sym
                                 [[type-name-sym
                                   [(ast/fn-arity-ast (str type-sym "_type_name") ""
                                                      (ast/params [x*]) "" []
                                                      [(str type-sym)])]]
                                  [has-field-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_has_field") ""
                                     (ast/params [x* field*]) "" []
                                     [(ast/or-ast
                                       (map fields
                                            (fn [field]
                                              (ast/call-ast identical-sym
                                                            [(rdr/tag (symbol (str "." field)))
                                                             field*]))))])]]]

                                 Eq-sym
                                 [[=*-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_EQ_STAR_") ""
                                     (ast/params [x* y*]) "" []
                                     [(ast/and-ast
                                       (list (ast/call-ast
                                              =*-sym [(ast/call-ast get-type-sym [x*])
                                                             (ast/call-ast get-type-sym [y*])])
                                             (ast/call-ast
                                              =*-sym [(ast/call-ast 'type-args [x*])
                                                             (ast/call-ast 'type-args [y*])])))])]]]

                                 Associative-sym
                                 [[get-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_get") ""
                                     (ast/params [x* field*]) "" []
                                     [(ast/and-ast
                                       (list
                                        (ast/call-ast has-field-sym [x* field*])
                                        (ast/call-ast maybe-sym [(ast/call-ast field*
                                                                              (list x*))])))])]]]

                                 HashMapNode-sym
                                 [[assoc*-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_assoc_STAR_") ""
                                     (ast/params [x* field* 'new-value '_ '_]) "" []
                                     [(ast/call-ast
                                       extract-sym
                                       [(ast/or-ast
                                         (list (ast/and-ast
                                                (list
                                                 (ast/call-ast has-field-sym [x* field*])
                                                 (ast/call-ast
                                                  maybe-sym
                                                  [(ast/call-ast field* (list x* 'new-value))])))
                                               (ast/call-ast maybe-sym [x*])))])])]]]}
                                impls))])))

(defn create-getters [sym fields]
  (let [type-value (symbol "#value")
        new-value (symbol "#new-value")]
    {Type-sym
     (map (zip-lists (seq fields) (range (count fields)))
          (fn [[field field-index]]
            [(rdr/tag  (symbol (str "." field)))
             [(ast/fn-arity-ast (str sym "_" field) ""
                                (ast/params [type-value new-value]) "" []
                                [(ast/call-ast
                                  make-value-sym
                                  [type-value
                                   (ast/call-ast extract-sym
                                                 [(ast/call-ast store-sym
                                                                [(ast/call-ast
                                                                  reified-type-args-sym
                                                                  [type-value])
                                                                 field-index new-value])])])])
              (ast/fn-arity-ast (str sym "_" field) ""
                                (ast/params [type-value]) "" []
                                [(ast/call-ast
                                  extract-sym
                                  [(ast/call-ast
                                    nth-sym [(ast/call-ast reified-type-args-sym
                                                                  [type-value])
                                                    field-index])])])]]))}))

(defn destructure-fields [sym ast]
  (map-vals (.impls ast)
            (fn [impl-arities]
              (map impl-arities
                   (fn [[fn-name impls]]
                     [fn-name (map impls
                                   (fn [arity]
                                     (let [[type-value-parameter] (.fixed (.params arity))
                                           new-body [(ast/let-ast [(ast/binding (.fields ast)
                                                                     (ast/call-ast
                                                                      reified-type-args-sym
                                                                      [type-value-parameter]))]
                                                                  (.body arity))]]
                                       (-> arity
                                           (.body new-body)
                                           (.fn-sym (str sym "_" fn-name))))))])))))

(extend-type ast/type-ast
  Emitter
  (emit-definition [ast]
    (let [file-name (ast/file-name ast)
          sym (.sym ast)
          fields (.fixed (.fields ast))
          const-arity-index (inc (count fields))
          impls (merge-with comp
                            (create-getters sym fields)
                            (destructure-fields sym ast))]
      (comp (for [_ (sm/get-in-val [.modules file-name .types sym])
                  _ (compilation-error (str "Trying to re-define type name: '" sym "' in module "
                                            file-name ", " (ast/line-number ast)))]
              "")
            
            (for [type-val-sym (global-var "#type-val-")
                  :let [type-val-sym (rdr/tag type-val-sym
                                              (ast/file-name sym)
                                              (ast/line-number sym))]
                  type-val-decl (emit-definition (ast/declaration-ast type-val-sym))
                  getters (declare-getters sym fields)

                  type-constructor (emit-definition (constructor-expr sym type-val-sym fields))
                  const-type-num (sm/get-in-val [.modules file-name .values sym .type-num])

                  type-val-def (emit-definition (type-val-expr sym type-val-sym fields impls))
                  type-num (sm/get-in-val [.modules file-name .values type-val-sym .type-num])
                  constructor-arity (get-proto-impl invoke-sym const-arity-index const-type-num)
                  _ (sm/assoc-in-val [.fns (.c-var constructor-arity) const-arity-index .type-num]
                                     type-num)
                  _ (sm/assoc-in-val [.modules file-name .types sym] type-num)]
              (comp type-val-decl
                    [(c-code "" [] (flatten getters) UnknownType {})]
                    type-constructor
                    type-val-def))))))

(def global-context (GlobalContext 'C
                                   (FunctionArityContext {} 0 {} {} empty-closures)
                                   (RuntimeInit (FunctionArityContext {} 0 {} {} empty-closures)
                                                [])
                                   {}                       ;; map for module info
                                   {}                       ;; map for static fns
                                   {}                       ;; map for namespaces
                                   (ConstantValues {} {} {} type-names)
                                   0                        ;; reify-fn-index
                                   ))

(def string-writer (agent ""))

(def logger (agent ""))
(defn log [& msg]
  (send logger (fn [_]
                 (apply print-err msg))))

(defprotocol StringWriter
  (write-str [x]
    (print x)))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str)))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str)))

(defprotocol FreeGlobal
  (free-global [_] []))

(extend-type c-init
  FreeGlobal
  (free-global [c-info]
    ["freeGlobal(" (.c-var c-info) ");" line-sep]))

(defn write-strings [strs]
  (send string-writer (fn [_]
                        (write-str strs))))

(def emit-main*
  (for [main-fn (comp (lookup-static-arity 'main 1)
                      (compilation-error "'main' function is missing"))
        values (sm/get-in-val [.init .exprs])]
    (write-strings ["\nint main (int argc, char **argv) {\n"
                    "maybeNothing = maybe((List *)0, (Value *)0, nothing);\n"
                    "maybeNothing->refs = -1;\n"
                    "outstream = stdout;\n"
                    "__atomic_store(&futuresQueue.input, &empty_list, __ATOMIC_RELAXED);\n"
                    "futuresQueue.output = empty_list;\n"
                    "pthread_mutex_init(&futuresQueue.mutex, NULL);\n"
                    "pthread_cond_init(&futuresQueue.notEmpty, NULL);\n"
                    "pthread_mutex_init(&shutDown.access, NULL);\n"
                    "startWorkers();\n"
                    (map values .init) "\n"
                    "  List *argList = malloc_list();\n"
                    "  argList->len = 0;\n"
                    "  argList->head = (Value *)0;\n"
                    "  argList->tail = (List *)0;\n"
                    "  List *tail = argList;\n"
                    "  for(int i = 0; i < argc; i++) {\n"
                    "     List *newTail = malloc_list();\n"
                    "     newTail->len = 0;\n"
                    "     newTail->tail = (List *)0;\n"
                    "     newTail->head = (Value *)0;\n"
                    "     tail->head = stringValue(argv[i]);\n"
                    "     tail->tail = newTail;\n"
                    "     tail = newTail;\n"
                    "     argList->len++;\n}\n"
                    "  argList->refs = -1;\n"
                    "Value *the_final_answer = " (.c-var main-fn)
                    "((List *)empty_list, (Value *)argList);\n\n"
                    "#ifdef CHECK_MEM_LEAK\n"
                    "cleaningUp = 1;\n"
                    (map values free-global)
                    "mainThreadDone = 1;\n"
                    "waitForWorkers();\n"
                    "dec_and_free(the_final_answer, 1);\n"
                    "freeGlobal((Value *)argList);\n"
                    "freeGlobal(maybeNothing);\n"
                    "freeAll();\n"
                    "if (malloc_count - free_count != 0)\n"
                    "   return(1);\n"
                    "#endif\n"
                    "  return(0);\n};\n"])))

(defn emit-proto-dispatcher [fn-name proto-disp]
  (let [num-args (.arg-count proto-disp)
        args (map (range num-args) (partial str "arg"))
        impls-sym (.impls-sym proto-disp)
        impls (.type-impls proto-disp)
        arity-sym (gensym "protoFnArity")
        dispatcher (StaticArity
                    (str "&" arity-sym) num-args UnknownType
                    (c-code (str "&" arity-sym)
                            []
                            ["\n// " fn-name " " num-args " args\n"
                             "ProtoImpls " impls-sym " = {"
                             (count impls) ", {"
                             (rest (flat-map (vals impls)
                                             ;; [type arity-sym fn-sym]
                                             (fn [type-impl]
                                               [", " "{" (.dispatch-type type-impl)
                                                ", (Value *)" (.c-var type-impl)
                                                "}"])))
                             "}};\n"
                             "Value *" (.dispatch-sym proto-disp) "("
                             (interpose (conj (map args (fn [arg] (str "Value *" arg)))
                                              "List *closures")
                                        ", ")
                             ") {\n"
                             "  return(proto" num-args "Arg(&" impls-sym ", \""
                             fn-name "\", " (interpose
                                             (comp args
                                                   [(str "\"" (ast/file-name fn-name) "\"")
                                                    (ast/line-number fn-name)])
                                             ", ")
                             "));\n}\n"
                             "FnArity " arity-sym " = {FnArityType, -1, "
                             num-args ", (List *)0, 0, " (.dispatch-sym proto-disp) "};\n"]
                            FnArityType {}))]
    (sm/state-maybe dispatcher)))

(defn emit-proto-fn [proto-fn]
  (let [fn-sym (gensym "protoFn")]
    (for [arities (traverse (vals (.dispatchers proto-fn))
                            (partial emit-proto-dispatcher (.fn-sym proto-fn)))]
      (c-code "" []
              [(map arities (fn [arity] (.decl (.var-info arity))))
               "Function " fn-sym " = {FunctionType, -1, \""
               (.fn-sym proto-fn) "\", " (count arities) ", {"
               (interpose (map arities .arity-fn-var) ", ")
               "}};\n" "Value *" (.disp-sym proto-fn) " = (Value *)&" fn-sym ";\n\n"]
              UnknownType {}))))

(defn get-proto-dispatch-sym [fn-name num-args]
  (sm/get-in-val [.modules 'core .proto-fns fn-name .dispatchers num-args .dispatch-sym]))

(def ast-emitter (agent (maybe global-context)))

(defn update-context [context update]
  (flat-map (flat-map context update) second))

(defn new-module [context module-name]
  (assert (instance? Maybe context))
  (update-context context
                  (comp (sm/get-in-val [.modules module-name])
                        (sm/assoc-in-val [.modules module-name]
                                         (Module module-name {} {} {} core-types {}))
                        (compilation-error "Compilation error (Could not prepare new module"
                                           module-name ".)"))))

(defn emit-ast [context ast]
  (assert (instance? Maybe context))
  (update-context context
                  (comp (for [emitted (emit-definition ast)
                              :let [_ (map emitted (fn [expr]
                                                     (write-strings (.decl expr))))]
                              _ (sm/update-in-val [.init .exprs] (fn [exprs]
                                                                   (comp exprs emitted)))]
                          "")
                        (compilation-error "Could not emit code for expression at "
                                           (ast/file-name ast) (ast/line-number ast)))))

(defn emit-main [context]
  (assert (instance? Maybe context))
  (update-context context
                  (comp emit-main*
                        (compilation-error "Compilation error (Could not emit 'main' function.)"))))

(def finalize-protocols*
  (for [modules (map (sm/get-val .modules) vals)
        dispatchers (traverse (for [module modules
                                    proto-fn (vals (.proto-fns module))]
                                proto-fn)
                              emit-proto-fn)]
    (map dispatchers (fn [expr] (write-strings (.decl expr))))))

(defn finalize-protocols [context]
  (assert (instance? Maybe context))
  (update-context context
                  (comp finalize-protocols*
                        (compilation-error "Compilation error (Could not finalize protocols.)"))))

(def fixup-native-symbols*
  (apply-to (fn [& decl]
              (write-strings decl))
            (map (get-proto-dispatch-sym (rdr/tag 'type-name) 1)
                 (fn [arity-sym]
                   ["Value *(*type_name)(List *, Value *) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'invoke) 1)
                 (fn [arity-sym]
                   ["Value *(*invoke0Args)(List *, Value *) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'invoke) 2)
                 (fn [arity-sym]
                   ["Value *(*invoke1Arg)(List *, Value *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'invoke) 3)
                 (fn [arity-sym]
                   ["Value *(*invoke2Args)(List *, Value *, Value*, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag '=*) 2)
                 (fn [arity-sym]
                   ["Value *(*equalSTAR)(List *, Value *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'hash-seq) 2)
                 (fn [arity-sym]
                   ["Value *(*hashSeq)(List *, Value*, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'count) 1)
                 (fn [arity-sym]
                   ["Value *(*count)(List *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'sha1) 1)
                 (fn [arity-sym]
                   ["Value *(*sha1)(List *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'assoc*) 5)
                 (fn [arity-sym]
                   ["Value *(*assoc)(List *, Value*, Value*, Value*, Value*, Value*) = "
                    arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'dissoc*) 4)
                 (fn [arity-sym]
                   ["Value *(*dissoc)(List *, Value*, Value*, Value*, Value*) = "
                    arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'get*) 5)
                 (fn [arity-sym]
                   ["Value *(*get)(List *, Value*, Value*, Value*, Value*, Value*) = "
                    arity-sym ";\n"]))

            (map (lookup-core-fn-arity (rdr/tag 'show) 1)
                 (fn [arity-sym]
                   ["Value *(*showFn)(List *, Value *) = " (.c-var arity-sym) ";\n"]))

            (map (lookup-core-fn-arity (rdr/tag 'fn-apply) 2)
                 (fn [arity-sym]
                   ["Value *(*fn_apply)(List *, Value*, Value*) = "
                    (.c-var arity-sym) ";\n"]))))

(defn fixup-native-symbols [context]
  (assert (instance? Maybe context))
  (update-context context
                  (comp fixup-native-symbols*
                        (compilation-error "Compilation error (Could not fixup native symbols.)"))))

(defn file-directory [src-file-name]
  (map (sys/realpath src-file-name)
       (fn [real-path]
         (let [[path-len] (reduce real-path [-1 0]
                                  (fn [[slash-pos c-pos] c]
                                    (let [c-pos (inc c-pos)]
                                      ((= c "/")
                                       [c-pos c-pos]
                                       [slash-pos c-pos]))))]
           (subs real-path 0 path-len)))))

(def compile-module)
(def module-compiler (agent {}))

(defprotocol ASTEmitter
  (send-to-emitter [ast]
    (send ast-emitter emit-ast ast))
  (add-namespace [ast root-dir proj-dir])
  (load-module [ast root-dir proj-dir]))

(extend-type ast/module-ast
  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [waiter (promise)
          file-path (str root-dir (.file-path ast))]
      (send module-compiler compile-module file-path waiter root-dir proj-dir)
      [waiter file-path])))

(def clone-repo)
(def repo-cloner (agent {}))

(defn clone-repo* [ast root-dir proj-dir]
  (let [opts (.args ast) 
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        branch (either (or (get opts 'tag)
                           (get opts 'branch))
                       "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)]
    (either (and (sys/sh-proc "/usr/bin/git" (list "clone" "--branch" branch
                                                   (.repo ast) dep-path))
                 (or (map (get opts 'sha)
                          (fn [sha]
                            ;; working with the OS. Give it a chance to catch up
                            (sys/sleep 3)
                            (or (sys/sh-proc "/usr/bin/git"
                                             (list "-C" dep-path "checkout" sha))
                                (do
                                  (print-err "Failed checkout of" sha "in" dep-path)
                                  (abort)))
                            (sys/sleep 3)))
                     (maybe (sys/sleep 3))))
            (do
              (print-err "Cloning git dependency" (.repo ast) "failed.")
              (abort)))
    dep-path))

(defn clone-repo [cloned ast waiter root-dir proj-dir]
  (let [opts (.args ast) 
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)
        module-path (str dep-path "/" (.file ast))]
    (either (or (map (sys/access module-path) (fn [_]
                                                (deliver waiter dep-path)
                                                cloned))
                (and (sys/access dep-path)
                     (do
                       (print-err "Dependency file" (.file ast)
                                  "missing from existing copy of repository"
                                  (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
                       (abort)))
                (update cloned dep-path (fn [cloning-future]
                                          (map cloning-future (partial deliver waiter))
                                          cloning-future))) 
            (assoc cloned dep-path (future (fn []
                                             (let [dep-path (clone-repo* ast root-dir proj-dir)]
                                               (deliver waiter dep-path)
                                               dep-path)))))))

(extend-type ast/git-dep-ast
  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [file (.file ast)]
      (or (-> file
              seq 
              (filter (partial = "/"))
              empty?)
          (do
            (print-err "For git dependencies,"
                       "files may only be imported from root of repository,"
                       file "is invalid.")
            (abort)))

      (let [clone-waiter (promise)
            dep-path (do
                       (send repo-cloner clone-repo ast clone-waiter root-dir proj-dir)
                       (extract clone-waiter))
            waiter (promise)
            module-path (str dep-path "/" file)]
        (or (sys/access module-path)
            (do
              (print-err "Dependency file" file "missing from cloned repository"
                         (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
              (abort)))
        (send module-compiler compile-module module-path waiter (str dep-path "/") proj-dir)
        [waiter module-path]))))

(extend-type ast/add-ns-ast
  ASTEmitter
  (add-namespace [ast root-dir proj-dir]
    (let [[waiter mod-file-name] (load-module (.mod ast) root-dir proj-dir)]
      (send ast-emitter
            (fn [context]
              (update-context context
                              (sm/assoc-in-val [.namespaces (ast/file-name ast)
                                                (rdr/tag (.ns-sym ast))]
                                               mod-file-name))))
      waiter)))

(def analyze-forms
  (rd/parser (grmr/none-or-more
              (grmr/any
               (grmr/apply-fn (fn [modules]
                                (map modules extract))
                              (grmr/one-or-more
                               (grmr/apply-fn add-namespace
                                              rdr/read-add-ns
                                              (grmr/get-value 'root-directory)
                                              (grmr/get-value 'project-directory))))
               (grmr/apply-fn send-to-emitter
                              rdr/top-level)))))

(def path-to-core (extract (or (map (sys/get-environment "TOCCATA_DIR")
                                    (fn [toc-dir]
                                      (str toc-dir "/core.toc")))
                               (do
                                 (print-err "Could not read environnment variable"
                                            "TOCCATA_DIR")
                                 (abort)))))

(defn load-core [modules]
  (either (or (and (get modules 'core)
                   (maybe modules))
              (for [file-in (fio/file-in path-to-core)
                    :let [_ (send ast-emitter new-module 'core)]
                    _ (analyze-forms {'file-name 'core
                                      'line-number 1
                                      'project-directory ""
                                      'root-directory ""}
                                     (lazy-list file-in))]
                (assoc modules 'core 'loaded)))
          (do
            (print-err "Could not compile Toccata core."
                       "Is the $TOCCATA_DIR environment variable set correctly?")
            (abort))))

(defn compile-module [loaded-modules file-name waiter-prom root-dir proj-dir]
  (let [loaded-modules (load-core loaded-modules)]
    (either (map (get loaded-modules file-name)
                 (fn [loaded]
                   (map loaded (fn [_]
                                 (deliver waiter-prom file-name)))
                   loaded-modules))
            (assoc loaded-modules file-name
                   (future (fn []
                             (either (flat-map (fio/file-in file-name)
                                               (fn [file-in]
                                                 (send ast-emitter new-module file-name)
                                                 (analyze-forms {'file-name file-name
                                                                 'root-directory root-dir
                                                                 'project-directory proj-dir
                                                                 'line-number 1}
                                                                (lazy-list file-in))))
                                     (do
                                       (print-err "Could not compile" file-name)
                                       (abort)))
                             (deliver waiter-prom file-name)))))))


(main [params]
      (let [[_ file-name] params
            waiter (promise)]
        (or (map (file-directory file-name)
                 (fn [root-dir]
                   (write-strings "\n#include <stdlib.h>\n#include \"core.h\"\n")
                   (send module-compiler compile-module file-name waiter root-dir root-dir)))
            (do
              (print-err "Could not find " (str "'" file-name "'"))
              (abort)))
        (extract waiter)
        (send ast-emitter emit-main)
        (send ast-emitter finalize-protocols)
        (send ast-emitter fixup-native-symbols)
        ;; wait for agents to clear their queues
        (let [waiter (promise)]
          (send ast-emitter (fn [_]
                              (send string-writer (fn [_]
                                                    (deliver waiter 'x)))))
          (extract waiter))))

