
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "8e7ab8d"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "cfa630d"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "1616a3a"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "956a8bb"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "b41dd1d"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "e67c808"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "d1125f5"))

(def line-sep "\n")

(defn line-macro [ast marker]
  (sm/state-maybe (either (= "" (ast/file-name ast))
                          ["\n" marker "\n// #line "
                           (str (ast/line-number ast)) " " "\""
                           (ast/file-name ast) "\"\n"])))

(def IgnoreType (inline C Integer "(Value *)&(Integer){IntegerType, -1, IgnoreType};"))
(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -1, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -1, IntegerType};"))
(def StringType (inline C Integer "(Value *)&(Integer){IntegerType, -1, StringType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FunctionType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ListType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, MaybeType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SymbolType};"))
(def BitmapIndexedType
  (inline C Integer "(Value *)&(Integer){IntegerType, -1, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ArrayNodeType};"))
(def HashCollisionNodeType
  (inline C Integer "(Value *)&(Integer){IntegerType, -1, HashCollisionNodeType};"))
(def HashMapType (inline C Integer "(Value *)&(Integer){IntegerType, -1, HashMapType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -1, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -1, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -1, OpaqueType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -1, TypeCount};"))

(def type-names {IntegerType "Integer"
                 StringType "String"
                 FnArityType "FnArity"
                 FunctionType "Function"
                 SubStringType "SubString"
                 ListType "List"
                 MaybeType "Maybe"
                 VectorType "Vector"
                 VectorNodeType "VectorNode"
                 SymbolType "Symbol"
                 BitmapIndexedType "BitmapIndexNode"
                 ArrayNodeType "ArrayNode"
                 HashCollisionNodeType "HashCollisionNode"
                 HashMapType "HashMap"
                 PromiseType "Promise"
                 FutureType "Future"
                 AgentType "Agent"
                 OpaqueType "Opaque"})

(defn target-type-name [n]
  (either (get type-names n)
          (str n)))

(def core-types {'Integer IntegerType
                 'String StringType
                 'SubString SubStringType
                 'FnArity FnArityType
                 'Function FunctionType
                 'List ListType
                 'Maybe MaybeType
                 'Vector VectorType
                 'Symbol SymbolType
                 'BitmapIndexedNode BitmapIndexedType
                 'ArrayNode ArrayNodeType
                 'HashCollisionNode HashCollisionNodeType
                 'HashMap HashMapType
                 'Promise PromiseType
                 'Future FutureType
                 'Agent AgentType
                 'Opaque OpaqueType
                 'TypeCount TypeCount})

(def sm-space (sm/state-maybe ""))

;; useful for debugging the compiler
(defn debug [& args]
  (map sm-space (fn [_] (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (sm/new-sm (fn [s]
               (apply print-err msg)
               (abort))))

(deftype ConstantValues [numbers strings symbols type-names]
  ;; numbers                static numbers
  ;; strings                static strings
  ;; symbols                static symbols
  ;; type-names             map of type numbers to type names
  )

(deftype RuntimeInit [fn-context exprs]
  ;; fn-context        context for the initialization code
  ;; exprs             the init expressions
  )

;; information that must be tracked for each module
(deftype Module [path values protocols proto-fns types declarations]
  ;; path             path to file containing the modules source code
  ;; values           map of value symbols to defined values
  ;; protocols        set of protocol symbols
  ;; proto-fns        map of protocol fn symbols to fn information
  ;; types            map of type symbols to type definitions
  ;; declarations     map of symbols to C vars that have not been defined
  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

;; There's a bunch of information to keep track of while compiling
(deftype GlobalContext [fn-context init modules fns namespaces constants reify-fn-index other]
  ;; target-lang            language to compile to
  ;; fn-context             context for the fn currently being compiled
  ;; modules                info for each module compiled
  ;; numbers                static numbers
  ;; strings                static strings
  ;; fns                    static functions
  ;; namespaces             current namespace map
  ;; other                  a map of anything
  Stringable
  (string-list [_] (list "<GlobalContext>"))
)

(deftype Closures [closures refs-map])
(def empty-closures (Closures empty-list {}))

(deftype TypeConstraint [type-num path])

;; Every function arity has some information that's local to it
(deftype FunctionArityContext [recurse sym-count syms context closed-over constraints]
  ;; recurse       info to detect recursive calls
  ;; sym-count     number of C variables already used in this fn
  ;; syms          the symbols local to the function that are currently interned
  ;; context
  ;; closed-over   symbols that this function closes over
  ;; constraints   map of symbols to their constraints
  Stringable
  (string-list [_]
    (list "<FunctionArityContext " (str (count syms)) ">")))

(defn reset-fn-context
  ([]
   (for [curr-fn-context (sm/get-val .fn-context)
         :let [new-context (comp (.context curr-fn-context) (.syms curr-fn-context))]
         _ (sm/set-val .fn-context (FunctionArityContext {} 0 {} new-context empty-closures {}))]
     curr-fn-context))
  ([new-fn-context]
   (for [curr-fn-context (sm/get-val .fn-context)
         _ (sm/set-val .fn-context new-fn-context)]
     curr-fn-context)))

(defprotocol Emitter
  ;; For AST nodes that can be embedded in other AST nodes
  (emit [_]
    ;; (assert-result x (instance? sm/new-sm x))
    )

  ;; For AST nodes that can be assigned to a symbol at the top level
  (emit-defined-value [ast defined-sym]
    ;; (assert-result x (instance? sm/new-sm x))
    )

  ;; why is this defined by the AST at analysis time? does every form that could evaluate to a value meet the defined-value test?

  ;; For AST nodes that can appear at the top level of a file
  (emit-definition [_]
    ;; (assert-result x (instance? sm/new-sm x))
    )

  ;; Mark this AST node as the final (or tail) expression in a function body
  (tail-call [_ params return-constraints])

  ;; Does 'ast' produce any executable code when emitted?
  (produces-code? [ast]
    ;; (assert-result x (instance? Maybe x))
    (maybe ast))

  ;; Emit a call expression if the call target is a tagged-symbol. Otherwise, fail
  (emit-call-expr [target-ast args]
    ;; (assert-result x (instance? sm/new-sm x))
    (zero sm/state-maybe))

    ;; does this mean computed function values are not allowed?
    ;; e.g., ((get-in [.x] methods) 10)

  ;; replace all occurances of the keys in 'subs' with their associated values
  (replace-syms [ast subs])

  ;; prepend "#" to all the bound variables in the AST
  (replace-bound-vars [ast subs]
    ast)

  ;; expand 'target-ast' so that it's component asts are inlined
  (inline-expr [target-ast arg-asts]
    (zero sm/state-maybe))

  ;; generate a new local C var for a symbol
  (bind [binding]
    ;; (assert-result x (instance? sm/new-sm x))
    )

  ;; bind the symbol 'binding' to the results of 'evalled'
  (bind [binding evalled]
    ;; (assert-result x (instance? sm/new-sm x))
    ))

;; combine a sequence of expressions, adding reference increments and decrements
;; where needed
(defprotocol CollapseExprs
  (collapse-expressions* [x y]))

;; information about a compiled expression(s)
;; c-var: C variable that holds the value produced by the code
;; init: C code that produces the value at run time
;; decl: C code to declare anything needed
;; type-num: the Toccata type of the value produced
;; refs-map: map of C variables that are used in 'init' and how many times
(deftype empty-code [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<Empty-C-Code>"))

  Collection
  (empty? [c]
    (maybe c))

  Composition
  (zero [c] c)
  (comp* [_ cs]
    (apply comp cs))

  CollapseExprs
  (collapse-expressions* [x y] y)

  Emitter
  (emit [x]
    (sm/state-maybe x)))

(def empty-c-code (empty-code "" [] [] UnknownType {}))

(deftype c-code [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", " (target-type-name type-num) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ">"))

  Composition
  (zero [_] empty-c-code)
  (comp* [c cs]
    (reduce cs c collapse-expressions*))

  Collection
  (empty? [c]
    (and (empty? (.init c))
         (empty? (.decl c))))

  CollapseExprs
  (collapse-expressions* [x y]
    (c-code (.c-var y)
            [(.init x) (.init y)]
            [(.decl x) (.decl y)]
            (.type-num y)
            (merge-with + (.refs-map x) (.refs-map y))))

  Emitter
  (emit [x]
    (sm/state-maybe x)))

;; same as 'c-code', but is the first appearance of 'c-var' in the generated code
(deftype c-init [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<C-Init " (str c-var) ", " (target-type-name type-num) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ">"))

  Collection
  (empty? [c] nothing)

  Composition
  (zero [_] empty-c-code)
  (comp* [c cs]
    (reduce cs c (fn [result c]
                   (c-code (.c-var c)
                           [(.init result) (.init c)]
                           [(.decl result) (.decl c)]
                           (.type-num c)
                           (merge-with + (.refs-map result) (.refs-map c))))))

  CollapseExprs
  (collapse-expressions* [x y]
    (let [init (either (or (for [refs (get-in y [.refs-map c-var])]
                              [(.init x)
                               ((< refs 2) "" [line-sep "incRef(" c-var ", " (dec refs) ");" line-sep])
                               (.init y)])
                            (and (= "" c-var)
                                 (maybe [(.init x) (.init y)])))
                       [(.init x)
                        line-sep "dec_and_free(" c-var ", 1);" line-sep
                        (.init y)])
          refs-map (merge-with + (.refs-map x) (.refs-map y))
          refs-map (assoc refs-map c-var 0)]
      (c-code (.c-var y)
              init
              [(.decl x) (.decl y)]
              (.type-num y)
              refs-map)))

  Emitter
  (emit [x]
    (sm/state-maybe x)))

(defn collapse-expressions [cs]
  (either (and (empty? cs) (maybe empty-c-code))
          (let [[c & cs] (reverse cs)
                cs (remove cs empty?)]
            (reduce cs c (fn [y x]
                           (collapse-expressions* x y))))))

(defn sym-ns-path [sym]
  (comp (for [ns-sym (sm/when (rdr/namespace sym))
              path (comp (sm/get-in-val [.namespaces (ast/file-name sym) ns-sym])
                         (sm/get-in-val [.namespaces (ast/file-name sym) (rdr/tag ns-sym)]))]
          path)
        (sm/state-maybe (ast/file-name sym))))

(defn new-protocol [proto-sym]
  ;; Initialize a new protocol definition in a module if it does not already exist.
  ;; Ensure all protocol symbols are unique
  (comp (for [_ (sm/get-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym])
              _ (compilation-error "Duplicate protocol" (str "'" proto-sym "'") "at"
                                   (str (ast/file-name proto-sym) ":")
                                   (ast/line-number proto-sym))]
          "")
        (sm/assoc-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym]
                         proto-sym)))

(defn get-protocol [proto-sym]
  ;; Look for the protocol information
  ;; 1. using the namespace portion of the protocol symbol
  ;; 2. using `'core` for protcols defined in the core
  (comp (for [protocol-path (sym-ns-path proto-sym)
              proto-info (sm/get-in-val [.modules protocol-path .protocols proto-sym])]
          proto-info)
        (sm/get-in-val [.modules 'core .protocols proto-sym])))

(deftype ProtoFnInfo [fn-sym disp-sym dispatchers]
  Stringable
  (string-list [_] (list "<ProtoFnInfo " fn-sym ">")))

(defn new-protocol-fn [fn-sym disp-sym]
  (comp (for [_ (sm/get-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym])
              _ (compilation-error "Duplicate protocol function" (str "'" fn-sym "'") "at"
                                   (str (ast/file-name fn-sym) ":") (ast/line-number fn-sym))]
          "")
        (sm/assoc-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym]
                         (ProtoFnInfo fn-sym disp-sym {}))))

(defn lookup-protocol-path [fn-sym path]
  ;; is protocol function `fn-sym` declared in module at 'path'
  (map (sm/get-in-val [.modules path .proto-fns fn-sym])
       (fn [_] path)))

(defn find-protocol-path [fn-sym]
  (comp (for [namespace (sym-ns-path fn-sym)
              path (lookup-protocol-path fn-sym namespace)]
          path)
        (lookup-protocol-path fn-sym (ast/file-name fn-sym))
        (lookup-protocol-path fn-sym 'core)))

(deftype ProtocolDispatcher [arg-count dispatch-sym impls-sym return-type
                             return-constraints type-impls]
  Stringable
  (string-list [_] (list "<ProtoDispatcher " (str arg-count) " " (str return-type) ">")))

(defn new-proto-dispatcher [fn-sym arg-count dispatch-sym impls-sym return-type return-constraints]
  (sm/assoc-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym .dispatchers arg-count]
                   (ProtocolDispatcher arg-count dispatch-sym impls-sym
                                       return-type return-constraints {})))

(defn get-protocol-dispatcher [fn-sym num-args]
  (for [protocol-path (find-protocol-path fn-sym)
        result (sm/get-in-val [.modules protocol-path .proto-fns fn-sym .dispatchers num-args])]
    result))

(deftype ProtoImpl [dispatch-type c-var ast]
  Stringable
  (string-list [_] (list "<ProtoImpl " (target-type-name dispatch-type) " " c-var ">")))

(defn new-proto-impl [fn-name arg-count dispatch-type c-code ast]
  (for [protocol-path (find-protocol-path fn-name)
        _ (sm/assoc-in-val [.modules protocol-path .proto-fns fn-name
                            .dispatchers arg-count .type-impls dispatch-type]
                           (ProtoImpl dispatch-type (.c-var c-code) ast))]
    ""))

(defn get-proto-impl [fn-name arg-count type-num]
  (for [protocol-path (find-protocol-path fn-name)
        impl-info (sm/get-in-val [.modules protocol-path .proto-fns fn-name
                                  .dispatchers arg-count .type-impls type-num])]
    impl-info))


(def C-var-punct (grmr/any (grmr/apply-fn (constantly "_STAR_")
                                          (grmr/ignore "*"))
                           (grmr/apply-fn (constantly "_HASH_")
                                          (grmr/ignore "#"))
                           (grmr/apply-fn (constantly "_PLUS_")
                                          (grmr/ignore "+"))
                           (grmr/apply-fn (constantly "_QM_")
                                          (grmr/ignore "?"))
                           (grmr/apply-fn (constantly "_BANG_")
                                          (grmr/ignore "!"))
                           (grmr/apply-fn (constantly "_EQ_")
                                          (grmr/ignore "="))
                           (grmr/apply-fn (constantly "_LT_")
                                          (grmr/ignore "<"))
                           (grmr/apply-fn (constantly "_GT_")
                                          (grmr/ignore ">"))))

(def C-var-remaining
  (grmr/none-or-more (grmr/any "_"
                               (grmr/apply-fn (constantly "_")
                                              (grmr/ignore "-"))
                               grmr/alpha
                               grmr/digit
                               C-var-punct)))

(def C-var (grmr/apply-fn (fn [start remaining]
                            (apply str start remaining))
                          (grmr/any grmr/alpha
                                    (map (grmr/ignore "#") (fn [] ""))
                                    (map (grmr/ignore "-") (fn [] "_MINUS_"))
                                    C-var-punct)
                          C-var-remaining))

(def check-C-var (rd/parser C-var))

(defn genlocal
  ([pre]
   (for [sym-count (sm/get-in-val [.fn-context .sym-count])
         _ (sm/assoc-in-val [.fn-context .sym-count] (inc sym-count))]
     (symbol (str pre sym-count))))
  ([sym arg-name]
   (for [sym-count (sm/get-in-val [.fn-context .sym-count])
         _ (sm/assoc-in-val [.fn-context .sym-count] (inc sym-count))]
     (symbol (str (either (check-C-var (str sym "_"))
                          arg-name)
                  sym-count)))))

(defn redef-proto-fn-error [sym]
  (for [path (find-protocol-path sym)
        _ (compilation-error "Redefining" (str "'" sym "'") "at"
                             (str (ast/file-name sym) ":") (ast/line-number sym)
                             "which is a protocol function in" path)]
    ""))

(deftype ParamBinding [vars destruct]
  Stringable
  (string-list [_]
    (comp (list "<ParamBinding ")
          (string-list vars)
          (list " ")
          (string-list destruct)
          (list ">")))

  Composition
  (comp* [x xs]
    (let [xs (cons x xs)]
      (ParamBinding (flat-map xs .vars) (flat-map xs .destruct)))))


(defn traverse [asts f]
  (reduce (reverse asts) (sm/state-maybe empty-list)
            (fn [l ast]
              (flat-map (f ast)
                        (fn [emitted]
                          (map l (fn [x]
                                   (cons emitted x))))))))

(extend-type List
  Emitter
  (emit [asts]
    (traverse asts emit))

  (tail-call [asts args return-constraints]
    (let [asts (-> asts
                   (filter produces-code?)
                   reverse)]
      (either (empty? asts)
              (let [[tail & init] asts]
                (-> (tail-call tail args return-constraints)
                    (cons init)
                    reverse))))))

(extend-type Vector
  Emitter
  (emit [asts]
    (traverse asts emit))

  (tail-call [asts params return-constraints]
    (let [asts (-> asts
                   (filter produces-code?)
                   reverse)]
      (extract (or (empty? asts)
                   (flat-map (last asts)
                             (fn [tail]
                               (store asts (dec (count asts))
                                      (tail-call tail params return-constraints)))))))))

;; generate symbols that are available globally inside the 'state-maybe' container
(defn global-var
  ([arg-name] (sm/state-maybe (gensym arg-name)))
  ([sym arg-name]
   (sm/state-maybe (gensym (either (check-C-var (str sym "_"))
                                   arg-name)))))


(defn lookup-module-def [sym]
  (let [sym-file (ast/file-name sym)]
    (comp (for [_ (sm/when (rdr/namespace sym))
                ns-file (sym-ns-path sym)
                var (comp (sm/get-in-val [.modules ns-file .values (.base sym)])
                          (sm/get-in-val [.modules ns-file .values (rdr/tag (.base sym))]))]
            var)
          (sm/get-in-val [.modules sym-file .values sym]))))

(defn new-module-def [sym value]
  (comp (redef-proto-fn-error sym)
        (for [r (sm/assoc-in-val [.modules (ast/file-name sym) .values sym] value)
              _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym] nothing)]
          r)))

(defn lookup-declaration [sym]
  (sm/get-in-val [.modules (ast/file-name sym) .declarations sym '_]))

(defn lookup-core-def [sym]
  (sm/get-in-val [.modules 'core .values sym]))

(defn already-closed-over [sym]
  (for [closed-over (sm/get-in-val [.fn-context .closed-over .closures])
        closure-var (sm/when (some closed-over (fn [[closure-var sym-literal]]
                                                 (for [_ (= sym sym-literal)]
                                                   closure-var))))
        _ (sm/update-in-val [.fn-context .closed-over .refs-map closure-var] inc)]
    closure-var))

(defn new-closure [sym]
  (for [closure-var (genlocal "val")
        _ (sm/update-in-val [.fn-context .closed-over .closures]
                            (fn [v] (conj v [closure-var sym])))
        _ (sm/assoc-in-val [.fn-context .closed-over .refs-map closure-var] 1)]
    closure-var))

(defn closed-over-sym [sym]
  (for [;; it's supposed to fail if 'sym' is not in the context
        c-sym (sm/get-in-val [.fn-context .context sym])

        ;; if 'sym' is in the context, it should be in .closed-over
        closure-var (comp (already-closed-over sym)
                          (new-closure sym))]
    (c-code closure-var [] [] (.type-num c-sym) {closure-var 1})))

(defn lookup-sym [sym]
  (comp (for [_ (sm/when-not (rdr/namespace sym))
              r (comp (sm/get-in-val [.fn-context .syms sym])
                      (closed-over-sym sym))]
          r)
        (comp (lookup-module-def sym)
              (lookup-declaration sym)
              (lookup-core-def sym)
              (compilation-error "Undefined symbol" (str "'" sym "'") "at"
                                 (str (ast/file-name sym) ":")
                                 (ast/line-number sym)))))

(deftype StaticArityInfo [c-info param-constraints])

;; we cache all the info about static function arities to optimize call sites
(defn lookup-static-arity [fn-var num-params]
  (sm/get-in-val [.fns fn-var num-params .c-info]))

(defn lookup-static-constraints [fn-var num-params]
  (sm/get-in-val [.fns fn-var num-params .param-constraints]))

(defn new-static-arity
  ([fn-var num-params arity-var type-num]
   (new-static-arity fn-var num-params arity-var type-num []))
  ([fn-var num-params arity-var type-num param-constraints]
   (sm/assoc-in-val [.fns fn-var num-params]
                    (StaticArityInfo (c-code arity-var [] [] type-num {})
                                     param-constraints))))

(defn lookup-core-fn-arity [sym num-args]
  (for [fn-sym (sm/get-in-val [.modules 'core .values sym])
        arity-sym (lookup-static-arity (.c-var fn-sym) num-args)]
    arity-sym))


(extend-type ast/block-comment-ast
  Emitter
  (produces-code? [ast] nothing)

  (emit [ast]
    (sm/state-maybe (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            [] 0 {})))

  (emit-defined-value [_ _] (sm/state-maybe []))
  (emit-definition [_] (sm/state-maybe []))

  (tail-call [ast params return-constraints] ast))


(defn make-static-string [str-val]
  (let [str-len (count str-val)]
    (for [str-idx (map (sm/get-in-val [.constants .strings]) count)
          :let [str-sym (str "str" str-idx)
                str-ptr (str "strPtr" str-idx)]
          _ (sm/assoc-in-val [.constants .strings str-val] (c-code str-ptr [] [] StringType {}))]
      (c-init str-ptr
              []
              ["struct {int64_t type;
        int32_t refs;
        int64_t len;
        Integer *hash;
        char buffer["
               (inc str-len)
               "];\n} " str-sym " = {StringType, -1, "
               str-len ", 0, \"" (escape-chars str-val) "\"};\n"
               "Value *" str-ptr " = (Value *)&" str-sym ";\n"]
              StringType {}))))

(defn make-c-code [value]
  (c-code (.c-var value) (.init value) (.decl value) (.type-num value) (.refs-map value)))

(defn get-type-number [type-symbol]
  (comp (for [type-symbol (sm/when type-symbol)
              ns-path (sym-ns-path type-symbol)
              type-num (comp (sm/get-in-val [.modules ns-path .types type-symbol])
                             (sm/get-in-val [.modules 'core .types type-symbol]))]
          type-num)
        (sm/state-maybe UnknownType)))

(defn set-type [sym type-num]
  (comp (for [sym-info (sm/get-in-val [.fn-context .syms sym])
              _ (sm/assoc-in-val [.fn-context .syms sym .type-num] type-num)]
          "")
        sm-space))

(defprotocol Assertion
  (assertion? [_] nothing)
  (return-assertion? [_] nothing)
  (format-path [_])
  (add-assertion [_])
  (check-assertion [ast arg var file-name line-number])
  (assert-type [_] nothing)
  (assert-return-type [_] nothing))

(extend-type ast/assert-ast
  Assertion
  (assertion? [ast]
    (maybe ast))

  (assert-type [ast]
    (assert-type (.assertion ast)))

  Emitter
  (produces-code? [ast] (produces-code? (.assertion ast)))

  (emit [ast]
    (let [assertion (.assertion ast)]
      (add-assertion (.path assertion (conj (.path assertion)
                                            [(str (ast/file-name ast) ":")
                                             (ast/line-number ast)])))))

  (tail-call [ast params return-constraints] ast))

(def string-types {StringType StringType
                   SubStringType SubStringType})
(def hash-map-types {BitmapIndexedType BitmapIndexedType
                     ArrayNodeType ArrayNodeType
                     HashCollisionNodeType HashCollisionNodeType
                     HashMapType HashMapType})

(defn is-same-type [x y]
  (assert (instance? Integer x))
  (assert (instance? Integer y))
  (inline C Maybe "
   if (sameType(((Integer *)x_0)->numVal, ((Integer *)y_1)->numVal)) {
     dec_and_free(y_1, 1);
     return(maybe((List *)0, (Value *)0, x_0));
   } else {
     dec_and_free(x_0, 1);
     dec_and_free(y_1, 1);
     return(nothing);
   }\n"))

(defn get-asserted-type [type-symbol file-name line-number]
  (comp (for [ns-path (sym-ns-path type-symbol)
              type-num (comp (sm/get-in-val [.modules ns-path .types type-symbol])
                             (sm/get-in-val [.modules 'core .types type-symbol]))]
          type-num)
        (compilation-error "Unknown type"
                           (str "'" type-symbol "'")
                           "in assertion at"
                           (str file-name ":")
                           line-number)))

(defn type-conflict [type1 type2]
  (flat-map (sm/state-maybe '_)
            (fn [_]
              (let [path1 (format-path type1)
                    path2 (format-path type2)
                    max-path (either (> (count path1) (count path2))
                                     (count path2))
                    path1 (either (map (< (count path1) max-path)
                                       (fn [_]
                                         (comp path1 (repeat (- max-path (count path1)) ""))))
                                  path1)
                    path2 (either (map (< (count path2) max-path)
                                       (fn [_]
                                         (comp path2 (repeat (- max-path (count path2)) ""))))
                                  path2)
                    max-width (reduce path1 0 (fn [max s]
                                                (either (> max (count s))
                                                        (count s))))]
                (apply compilation-error "Conflicting assertions at"
                       (str (ast/file-name (.sym type2)) ":")
                       (ast/line-number (.sym type2))
                       "\nAssertions from\n"
                       (map (zip-lists path1 path2)
                            (fn [[x y]]
                              (str x (spaces (- max-width (count x))) "   " y "\n"))))))))

(extend-type ast/type-assertion
  Emitter
  (emit [ast]
    (for [type-num (get-asserted-type (.type-sym ast) (ast/file-name ast) (ast/line-number ast))
          var (lookup-sym (.sym ast))]
      (c-code ""
              ["if (!sameType(" (.c-var var) "->type, " type-num ")) {" line-sep
               "fprintf(stderr, \"Wrong type of result returned at %s, line %d\\n\", \""
               (ast/file-name ast) "\"," (ast/line-number ast)
               ");" line-sep
               "fprintf(stderr, \"Expected %s, got %s\\n\", \""
               (str (.type-sym ast)) "\", extractStr(type_name(empty_list, " (.c-var var)
               ")));" line-sep
               "abort();" line-sep
               "}" line-sep]
              [] UnknownType {})))

  Assertion
  (format-path [ast]
    (either (empty? (.path ast))
            (map (.path ast)
                 (fn [[file line]]
                   (str file " " line)))))

  (assert-type [ast] (maybe (.type-sym ast)))

  (add-assertion [ast]
    (comp (for [_ (sm/when (instance? rdr/tagged-symbol (.sym ast)))
                _ (comp (lookup-sym (.sym ast))
                        (compilation-error "Invalid type assertion at"
                                           (str (ast/file-name ast) ":")
                                           (str (ast/line-number ast) ".")
                                           "Symbol" (str "'" (.sym ast) "' not found.")))
                constraint-type (get-asserted-type (.type-sym ast)
                                                   (ast/file-name ast)
                                                   (ast/line-number ast))
                constraints (sm/get-in-val [.fn-context .constraints (.sym ast)]
                                           [])
                _ (comp (for [_ (sm/when-not (some constraints assert-type))
                              _ (sm/assoc-in-val [.fn-context .constraints (.sym ast)]
                                                 (conj constraints ast))
                              _ (set-type (.sym ast) constraint-type)]
                          'done)
                        (for [type-num (get-type-number (some constraints assert-type))
                              _ (either (map (is-same-type type-num constraint-type)
                                             sm/state-maybe)
                                        (-> constraints
                                            (filter assert-type)
                                            first
                                            extract
                                            (type-conflict ast)))]
                          'done))]
            empty-c-code)
          (sm/state-maybe empty-c-code)))

  (check-assertion [ast arg var file-name line-number]
    (for [constraint-type (get-asserted-type (.type-sym ast)
                                             (ast/file-name ast) (ast/line-number ast))
          _ (add-assertion (-> ast
                               (.sym arg)
                               (.path (conj (.path ast) [(str file-name ":")
                                                         line-number]))))
          expr (comp (for [_ (sm/when-not (= UnknownType (.type-num var)))
                           _ (comp (sm/when (is-same-type constraint-type (.type-num var)))
                                   (apply compilation-error "Failed type assertion at"
                                          (str file-name ":") (str line-number ".")
                                          "\nExpected" (str "'" (.type-sym ast) "'.")
                                          (-> "\nAssertion from" 
                                              (cons (format-path ast))
                                              (interpose "\n"))))]
                       empty-c-code)
                     (sm/state-maybe (c-code ""
                                             ["if (!sameType(" (.c-var var) "->type, "
                                              constraint-type ")) {" line-sep
                                              line-sep
                                              "fprintf(stderr, \"Invalid type of value"
                                              " at %s, line %d\\n\", \""
                                              file-name "\"," line-number
                                              ");" line-sep
                                              "fprintf(stderr, \"Needed %s, got %s\\n\", \""
                                              (str (.type-sym ast))
                                              "\", extractStr(type_name(empty_list, "
                                              (.c-var var) ")));" line-sep
                                              "abort();" line-sep
                                              "}" line-sep]
                                             [] constraint-type {})))]
      expr)))

(extend-type ast/result-ast
  Assertion
  (return-assertion? [ast] (maybe ast))

  (assert-return-type [ast]
    (for [type-sym (assert-type (.assertion ast))
          _ (= (.sym ast) (.sym (.assertion ast)))]
      type-sym))

  Emitter
  (produces-code? [ast] nothing)

  (emit [ast]
    (sm/state-maybe empty-c-code))

  (tail-call [ast params return-constraints] ast))

(defn emit-return-constraints [expr return-constraints]
  (traverse return-constraints
            (fn [constraint]
              (for [locals (sm/get-in-val [.fn-context .syms])
                    _ (sm/assoc-in-val [.fn-context .syms (.sym constraint)] expr)
                    const-expr (emit (.assertion constraint))
                    _ (sm/assoc-in-val [.fn-context .syms] locals)]
                const-expr))))

(defn emit-tail-expr [ast file-name line-number return-constraints expr]
  (comp (for [return-type (get-type-number (some return-constraints assert-return-type))
              :when (or (= return-type UnknownType)
                        (is-same-type return-type (.type-num expr)))
              return-assertions (emit-return-constraints expr (remove return-constraints
                                                                      assert-return-type))]
          (collapse-expressions (comp [expr]
                                      return-assertions
                                      [(c-code ""
                                               ["return(" (.c-var expr) ");" line-sep]
                                               [] (.type-num expr) {(.c-var expr) 1})])))
        (for [return-type (get-type-number (some return-constraints assert-return-type))
              _ (sm/when (= UnknownType (.type-num expr)))
              return-assertions (emit-return-constraints expr return-constraints)]
          (do
            ;; TODO: periodically enable this to check on things
            ;; (print-err 'check (some return-constraints assert-return-type) return-type
            ;;            (ast/file-name ast) (ast/line-number ast))
            (collapse-expressions (comp [(.type-num expr return-type)]
                                        return-assertions
                                        [(c-code ""
                                                 ["return(" (.c-var expr) ");" line-sep]
                                                 [] return-type {(.c-var expr) 1})]))))
        (sm/new-sm (fn [s]
                     (print-err "Return value fails return assertion:"
                                (ast/file-name return-constraints)
                                (ast/line-number return-constraints))
                     nothing))))

(deftype TailExpr [ast params return-constraints]
  Stringable
  (string-list [expr]
    (comp (list "<TailExpr ") (string-list ast) (list ">")))

  Emitter
  (emit [_]
    (comp (for [_ (sm/when (and (instance? ast/call-ast ast)
                                (or (instance? Symbol (.call-target ast))
                                    (instance? rdr/tagged-symbol (.call-target ast)))))
                target (emit (.call-target ast))
                _ (sm/get-in-val [.fn-context .recurse (.c-var target) (count (.args ast))])
                args (-> (.args ast)
                         (filter produces-code?)
                         emit)
                line (line-macro ast "// recursive-fixed")]
            (collapse-expressions (comp args
                                        [(c-init ""
                                                 [line
                                                  (map (zip-lists params (map args .c-var))
                                                       (fn [[param arg]]
                                                         [param " = " arg ";" line-sep]))]
                                                 [] IgnoreType
                                                 (reduce (map args .c-var) {}
                                                         (fn [m arg]
                                                           (assoc m arg 1))))])))
          (flat-map (emit ast)
                    (partial emit-tail-expr
                             ast
                             (ast/file-name ast)
                             (ast/line-number ast)
                             return-constraints)))))

(extend-type String
  Emitter
  (emit [str-val]
    (comp (sm/get-in-val [.constants .strings str-val])
          (make-static-string str-val)))

  (emit-defined-value [str-val defined-sym]
    (for [value (emit str-val)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] StringType {}))]
      [(make-c-code value)]))

  (tail-call [x params return-constraints]
    (TailExpr x params return-constraints)))


(defn make-static-num [num]
  (for [num-idx (map (sm/get-in-val [.constants .numbers]) count)
        :let [num-sym (str "num" num-idx)
              num-ptr (str "numPtr" num-idx)]
        _ (sm/assoc-in-val [.constants .numbers num]
                           (c-code num-ptr [] [] IntegerType {}))]
    (c-init num-ptr
            []
            ["Integer " num-sym " = {IntegerType, -1, " num "};\n"
             "Value *" num-ptr " = (Value *)&" num-sym ";\n"]
            IntegerType {})))

(extend-type Integer
  Emitter
  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast)

  (emit [num]
    (comp (sm/get-in-val [.constants .numbers num])
          (make-static-num num)))

  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] IntegerType {}))]
      [(make-c-code value)]))

  (tail-call [x params return-constraints]
    (TailExpr x params return-constraints)))


(extend-type ast/quoted-ast
  Emitter
  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast)

  (emit [ast]
    (let [sym (.q-val ast)]
      (comp (sm/get-in-val [.constants .symbols sym])
            (for [sym-idx (map (sm/get-in-val [.constants .symbols]) count)
                  :let [sym-var (str "sym" sym-idx)
                        sym-ptr (str "symPtr" sym-idx)]
                  _ (sm/assoc-in-val [.constants .symbols sym]
                                     (c-code sym-ptr [] [] SymbolType {}))]
              (c-code sym-ptr
                      []
                      ["SubString " sym-var " = {SymbolType, -1, " (count (str sym))
                       ", 0, 0, \"" sym "\"};\n"
                       "Value *" sym-ptr " = (Value *)&" sym-var ";\n"]
                      SymbolType {})))))

  (emit-defined-value [ast defined-sym]
    (for [quoted (emit ast)
          _ (new-module-def defined-sym (c-code (.c-var quoted) [] [] SymbolType {}))]
      [(make-c-code quoted)]))

  (tail-call [ast params return-constraints]
    (TailExpr ast params return-constraints)))


(defn call-vector [target args]
  (for [_ (sm/when (= target 'vector))
        vect-sym (genlocal "newVect")
        result-sym (genlocal "rslt")
        line (line-macro target "// call-vector")]
    (apply comp (comp args
                      [(c-init result-sym
                               [line
                                "Vector *" vect-sym " = empty_vect;" line-sep
                                (map args
                                     (fn [arg]
                                       (let [arg-sym (.c-var arg)]
                                         [vect-sym " = mutateVectConj(" vect-sym ", "
                                          arg-sym ");" line-sep])))
                                "Value *" result-sym " = (Value *)" vect-sym ";" line-sep]
                               [] VectorType {})]))))

(defn call-list [target args]
  (for [_ (sm/when (= target 'list))
        line (line-macro target "// call-list")
        list-sym (genlocal "newList")
        result-sym (genlocal "rslt")]
    (apply comp (comp args
                      [(c-init result-sym
                                [line "List *" list-sym " = empty_list;" line-sep
                                 (map (reverse args)
                                      (fn [arg]
                                        (let [arg-sym (.c-var arg)]
                                          [list-sym " = listCons(" "(Value *)" arg-sym
                                           ", " list-sym ");" line-sep])))
                                 "Value *" result-sym " = (Value *)" list-sym ";" line-sep]
                                [] ListType {})]))))

(defn dispatch-type-known [target args]
  (let [num-args (count args)]
    (for [dispatch-val (sm/when (first args))
          impl-info (get-proto-impl target num-args (.type-num dispatch-val))
          arity-info (lookup-static-arity (.c-var impl-info) num-args)
          _ (comp (sm/update-in-val [.other 'type-known-sites] inc)
                  (sm/assoc-in-val [.other 'type-known-sites] 0))
          result-sym (genlocal "rslt") 
          line (line-macro target (str "// type-known for " target))]
      (let [return-type (either (or (and (= (.type-num arity-info) UnknownType)
                                         ;; TODO: these should be the result of
                                         ;; asserts on the protocol fn defs
                                         (or (= target 'map)
                                             (= target 'rest)
                                             (= target 'assoc*))
                                         (maybe (.type-num dispatch-val))))
                                (.type-num arity-info))]
        (apply comp (comp args
                          [(c-init result-sym
                                   [line "Value *" result-sym " = " (.c-var arity-info) "("
                                    (interpose (conj (map args .c-var) "empty_list")
                                               ", ")
                                    ");" line-sep]
                                   []
                                   return-type {})]))))))

(defn dispatch-type-unknown [target args]
  (let [num-args (count args)]
    (for [impls-info (get-protocol-dispatcher target num-args)
          _ (comp (sm/update-in-val [.other 'type-unknown-sites] inc)
                  (sm/assoc-in-val [.other 'type-unknown-sites] 0))
          result-sym (genlocal "rslt")
          line (line-macro target (str "// type-unknown " target))]
      (apply comp (comp args
                        [(c-init result-sym
                                 [line "Value *" result-sym " = proto" num-args "Arg(&"
                                  (.impls-sym impls-info)
                                  ", \"" (.sym target) "\", "
                                  (interpose (comp (map args .c-var)
                                                   [(str "\"" (.file-name target) "\"")
                                                    (ast/line-number target)])
                                             ", ")
                                  ");" line-sep]
                                 []
                                 (.return-type impls-info) {})])))))

(defn call-proto-impl [name args]
  (for [_ (sm/when (< 0 (count args)))
        call-info (comp (dispatch-type-known name args)
                        (dispatch-type-unknown name args))]
    call-info))

(defn inline-wrap-and-apply* [name args]
  (let [num-args (count args)]
    (for [_ (sm/when (and (< 0 num-args)
                          (or (= 'wrap name)
                              (= 'apply* name))))
          :let [[dispatch-ast & arg-asts] args]
          dispatch-val (emit dispatch-ast)
          impl-ast (map (get-proto-impl name num-args (.type-num dispatch-val))
                        .ast)
          expr (-> impl-ast
                   (replace-bound-vars {})
                   (inline-expr (cons dispatch-val arg-asts)))]
      expr)))


(defn inline-flat-map [name args]
  (let [num-args (count args)]
    (for [_ (sm/when (and (= 2 num-args)
                          (or (= 'flat-map name)
                              (= 'map name))))
          :let [[dispatch-ast f-ast] args]
          dispatch-val (emit dispatch-ast)
          impl-ast (map (get-proto-impl name num-args (.type-num dispatch-val))
                        .ast)
          :let [impl-ast (replace-bound-vars impl-ast {})
                [dispatch-sym f-sym] (.fixed (.params impl-ast))]
          body-exprs (traverse (.body impl-ast)
                               (fn [ast]
                                 (replace-syms ast {f-sym f-ast})))]
      (ast/let-ast (list (ast/binding dispatch-sym dispatch-val))
                   body-exprs))))

(extend-type rdr/tagged-symbol
  Emitter
  (bind [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg (c-code arg-var [] [] UnknownType {arg-var 1})]
          _ (comp (redef-proto-fn-error binding)
                  (sm/assoc-in-val [.fn-context .syms binding] arg))]
      (ParamBinding [arg-var] [])))

  (bind [binding evalled]
    (for [arg-var (genlocal binding "arg")
          :let [evalled (-> evalled
                            (.c-var arg-var)
                            (.init [(.init evalled) "Value *" arg-var " = "
                                    (.c-var evalled) ";" line-sep]))
                evalled-ref (c-code (.c-var evalled) [] [] (.type-num evalled)
                                    {(.c-var evalled) 1})]
          _ (comp (redef-proto-fn-error binding)
                  (sm/assoc-in-val [.fn-context .syms binding] evalled-ref))]
      (either (and (empty? (.init evalled))
                   (maybe (ParamBinding [(.c-var evalled)] [evalled])))
              (ParamBinding [(.c-var evalled)]
                            [evalled (c-init (.c-var evalled) [] []
                                             (.type-num evalled) {})]))))

  (emit [sym]
    (lookup-sym sym))

  (emit-defined-value [sym defined-sym]
    (for [value (lookup-sym sym)
          _ (new-module-def defined-sym value)]
      [(make-c-code value)]))

  (tail-call [ast params return-constraints]
    (TailExpr ast params return-constraints))

  (emit-call-expr [target-ast args]
    (comp (call-vector target-ast args)
          (call-list target-ast args)
          (call-proto-impl target-ast args)))

  (replace-syms [ast subs]
    (sm/state-maybe (get subs ast ast)))

  (inline-expr [name arg-asts]
    (let [args (filter arg-asts produces-code?)]
      (comp (inline-wrap-and-apply* name args)
            (inline-flat-map name args))))

  (replace-bound-vars [ast subs]
    (get subs ast ast)))


(extend-type Symbol
  Emitter
  (bind [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg (c-code arg-var [] [] UnknownType {arg-var 1})]
          _ (comp (redef-proto-fn-error binding)
                  (sm/assoc-in-val [.fn-context .syms binding] arg))]
      (ParamBinding [arg-var] [])))

  (bind [binding evalled]
    (for [arg-var (genlocal binding "arg")
          :let [evalled (-> evalled
                            (.c-var arg-var)
                            (.init [(.init evalled) "Value *" arg-var " = "
                                    (.c-var evalled) ";" line-sep]))
                evalled-ref (c-code (.c-var evalled) [] [] (.type-num evalled)
                                    {(.c-var evalled) 1})]
          _ (comp (redef-proto-fn-error binding)
                  (sm/assoc-in-val [.fn-context .syms binding] evalled-ref))]
      (either (and (empty? (.init evalled))
                   (maybe (ParamBinding [(.c-var evalled)] [evalled])))
              (ParamBinding [(.c-var evalled)]
                            [evalled (c-init (.c-var evalled) [] []
                                             (.type-num evalled) {})]))))

  (emit [sym]
    (lookup-sym sym))

  (replace-syms [ast subs]
    (sm/state-maybe (get subs ast ast)))

  (inline-expr [name arg-asts]
    (let [args (filter arg-asts produces-code?)]
      (comp (inline-wrap-and-apply* name args)
            (inline-flat-map name args))))

  (replace-bound-vars [ast subs]
    (get subs ast ast)))


(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))]
      (c-code "" [(.txt ast)] [] type-num {})))

  (emit-defined-value [ast defined-sym]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))
          c-var (comp (map (lookup-declaration defined-sym) .c-var)
                      (global-var defined-sym "var"))
          _ (new-module-def defined-sym (c-code c-var [] [] type-num {}))]
      [(c-code "" [] ["Value *" c-var " = " (.txt ast) ";" line-sep] type-num {})]))

  ;; why test for lang equality, then emit c code? Does something else guarantee target-lang is always C when arriving here?
  (emit-definition [ast]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))]
      [(c-code "" [] [(.txt ast)] type-num {})]))

  (tail-call [ast params return-constraints]
    ;; TODO: statically verify the return type, if possible
    ast)

  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (for [evalled (traverse (.value ast) (fn [ast]
                                             (emit-defined-value ast defined-sym)))]
        (flatten evalled)))))

(extend-type ast/declaration-ast
  Emitter
  (emit-definition [ast]
    (let [sym (.sym ast)]
      (comp (map (lookup-declaration sym) (fn [_] []))
            (for [c-var (global-var sym "var")
                  :let [c-info (c-code c-var [] [] UnknownType {})]
                  _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym]
                                     (maybe c-info))]
              (let [c-info (.c-var c-info "")]
                [(.decl c-info ["Value *" c-var ";\n"])]))))))


;; optimize calls to static, fixed arity, functions
(defn call-static-fixed [target arg-vars ast]
  (for [arity-info (lookup-static-arity (.c-var target) (count arg-vars))
        _ (comp (sm/update-in-val [.other 'static-fixed-sites] inc)
                (sm/assoc-in-val [.other 'static-fixed-sites] 0))
        constraints (lookup-static-constraints (.c-var target) (count arg-vars))
        exprs (traverse (for [[var arg constraints] (zip-lists (seq arg-vars)
                                                               (seq (.args ast))
                                                               (seq constraints))
                              constraint constraints]
                          [constraint arg var])
                        (fn [[constraint arg var]]
                          (check-assertion constraint arg var
                                           (ast/file-name ast)
                                           (ast/line-number ast))))
        result-sym (genlocal "rslt")
        line (line-macro ast "// static-fixed")]
    (c-init result-sym
            [(map exprs .init)
             line "Value *" result-sym " = " (.c-var arity-info) "("
             (interpose (cons "empty_list" (seq (map arg-vars .c-var))) ", ") ");" line-sep]
            [] (.type-num arity-info) {})))

(defn call-static-variadic [target arg-vars ast]
  (for [arity-info (lookup-static-arity (.c-var target) 'variadic)
        _ (comp (sm/update-in-val [.other 'static-variadic-sites] inc)
                (sm/assoc-in-val [.other 'static-variadic-sites] 0))
        variadic-sym (genlocal "varArgs")
        result-sym (genlocal "rslt")
        line (line-macro ast "// static-variadic")]
    (c-init result-sym
            [line "List *" variadic-sym " = empty_list;" line-sep
             (map (reverse arg-vars)
                  (fn [arg-sym]
                    (str variadic-sym " = (List *)listCons("
                         "(Value *)" arg-sym
                         ", " variadic-sym ");" line-sep)))
             "Value *" result-sym " = " (.c-var arity-info) "(empty_list, (Value *)"
             variadic-sym ");" line-sep]
            []
            (.type-num arity-info)
            {})))

(defn call-dyn-fn-value [target args ast]
  (for [arity-sym (genlocal "arity")
        :when (= FunctionType (.type-num target))
        _ (comp (sm/update-in-val [.other 'dyn-fn-sites] inc)
                (sm/assoc-in-val [.other 'dyn-fn-sites] 0))
        variadic-sym (genlocal "dynArgs")
        fn-var (genlocal "fn")
        result-sym (genlocal "rslt")
        line (line-macro ast "// dynamic fn type")]
    (let [arg-syms (conj args (str arity-sym "->closures"))
          num-args (count args)]
      (c-init result-sym
              ["Value *" result-sym ";" line-sep
               "FnArity *" arity-sym " = findFnArity(" (.c-var target)
               ", " num-args ");" line-sep
               "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) { "
               "FnType" num-args " *" fn-var " = (FnType" num-args " *)"
               arity-sym "->fn;" line-sep
               "\n" line
               result-sym " = " fn-var "(" (to-str (interpose arg-syms ", ")) ");" line-sep
               "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) { "
               "FnType1 *" fn-var " = (FnType1 *)" arity-sym "->fn;" line-sep
               "List *" variadic-sym " = empty_list;" line-sep
               (map (reverse (rest arg-syms))
                    (fn [arg-sym]
                      (str variadic-sym " = (List *)listCons("
                           arg-sym ", " variadic-sym ");" line-sep)))
               line result-sym " = " fn-var "(" (str arity-sym) "->closures, (Value *)"
               variadic-sym ");" line-sep
               "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s' at: %s, %d.\\n\", "
               "((Function *)" (.c-var target) ")->name, \"" (ast/file-name ast)
               "\", " (ast/line-number ast) ");\n  abort();\n}\n"
               "dec_and_free("(.c-var target) ", 1);" line-sep]
              []
              UnknownType {}))))

(def invoke-sym (rdr/tag 'invoke))
(def Type-sym (rdr/tag 'Type))
(def Function-sym (rdr/tag 'Function))
(def Stringable-sym (rdr/tag 'Stringable))
(def type-name-sym (rdr/tag 'type-name))
(def =*-sym (rdr/tag '=*))
(def get-type-sym (rdr/tag 'get-type))
(def extract-sym (rdr/tag 'extract))
(def instance?-sym (rdr/tag 'instance?))
(def new-type-value-sym (rdr/tag 'new-type-value))
(def string-list-sym (rdr/tag 'string-list))
(def list-sym (rdr/tag 'list))
(def has-field-sym (rdr/tag 'has-field))
(def identical-sym (rdr/tag 'identical))
(def Eq-sym (rdr/tag 'Eq))
(def Associative-sym (rdr/tag 'Associative))
(def get-sym (rdr/tag 'get))
(def maybe-sym (rdr/tag 'maybe))
(def HashMapNode-sym (rdr/tag 'HashMapNode))
(def assoc*-sym (rdr/tag 'assoc*))
(def make-value-sym (rdr/tag 'make-value))
(def store-sym (rdr/tag 'store))
(def reified-type-args-sym (rdr/tag 'reified-type-args))
(def nth-sym (rdr/tag 'nth))

(defn call-dyn-unknown-type [target args ast]
  (let [num-args (count args)]
    (for [arity-sym (genlocal "arity")
          variadic-sym (genlocal "dynArgs")
          fn-sym (genlocal "fn")
          result-sym (genlocal "rslt")
          invoke-arity-sym (map (lookup-core-fn-arity invoke-sym (inc num-args))
                                .c-var)
          _ (comp (sm/update-in-val [.other 'dyn-unknown-sites] inc)
                  (sm/assoc-in-val [.other 'dyn-unknown-sites] 0))
          line (line-macro ast "// dynamic unknown type")]
      (let [arg-syms (conj args (str arity-sym "->closures"))]
        (c-init result-sym
                [line "Value *" result-sym ";" line-sep
                 "if((" (.c-var target) ")->type != FunctionType) {" line-sep

                 result-sym " = " invoke-arity-sym "(empty_list, "
                 (to-str (interpose (conj args (.c-var target)) ", "))
                 ");" line-sep "} else {" line-sep

                 "FnArity *" arity-sym " = findFnArity(" (.c-var target) ", " num-args ");" line-sep
                 "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) {" line-sep
                 "FnType" num-args " *" fn-sym " = (FnType" num-args " *)" arity-sym "->fn;" line-sep
                 result-sym " = " fn-sym "(" (to-str (interpose arg-syms ", ")) ");" line-sep
                 "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) {" line-sep
                 "FnType1 *" fn-sym " = (FnType1 *)" arity-sym "->fn;" line-sep
                 "List *" variadic-sym " = empty_list;" line-sep
                 (map (reverse (rest arg-syms))
                      (fn [arg-sym]
                        (str variadic-sym " = (List *)listCons("
                             arg-sym ", " variadic-sym ");" line-sep)))
                 result-sym " = " fn-sym "(" (str arity-sym) "->closures, (Value *)"
                 variadic-sym ");" line-sep
                 "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                 "((Function *)" (.c-var target) ")->name"
                 ");" line-sep "  abort();" line-sep "}" line-sep
                 "dec_and_free("(.c-var target) ", 1);" line-sep "}" line-sep]
                [] UnknownType {})))))

(defn call-invoke [target args ast]
  (let [num-args (inc (count args))]
    (for [invoke-info (get-proto-impl invoke-sym num-args (.type-num target))
          arity-info (lookup-static-arity (.c-var invoke-info) num-args)
          _ (comp (sm/update-in-val [.other 'invoke-sites] inc)
                  (sm/assoc-in-val [.other 'invoke-sites] 0))
          result-sym (genlocal "rslt")
          line (line-macro ast "// call invoke")]
      (c-init result-sym
              [line "Value *" result-sym " = " (.c-var arity-info) "("
               (interpose (conj (cons (.c-var target) args) "empty_list") ", ") ");" line-sep]
              []
              (.type-num arity-info)
              {}))))

(defn update-last [asts f]
  (either (empty? asts)
          (let [[tail & init] (-> asts
                                  (filter produces-code?)
                                  reverse)]
            (-> (f tail)
                (cons init)
                reverse))))

(defn make-bindings [params args]
  (map (zip-lists (seq params) (seq args))
       (fn [[param val]]
         (ast/binding-ast param val))))


(extend-type ast/call-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          ast (extract (update-in ast [.call-target]
                                  (fn [target-ast]
                                    ((instance? Symbol target-ast)
                                     (rdr/tag target-ast)
                                     target-ast))))]
      (comp (for [new-ast (inline-expr (.call-target ast) (.args ast))
                  call-site (emit new-ast)]
              (c-init (.c-var call-site) (.init call-site) (.decl call-site)
                      (.type-num call-site) (.refs-map call-site)))
            (for [args (-> (.args ast)
                           (filter produces-code?)
                           emit)
                  call-site (comp (emit-call-expr (.call-target ast) args)
                                  (for [target (emit (.call-target ast))
                                        :let [arg-vars (map args .c-var)]
                                        call-site (comp (call-static-fixed target args ast)
                                                        (call-static-variadic target arg-vars ast)
                                                        (call-invoke target arg-vars ast)
                                                        (call-dyn-fn-value target arg-vars ast)
                                                        (call-dyn-unknown-type target arg-vars ast))]
                                    (comp* empty-c-code (comp args [target call-site])))
                                  (compilation-error "Could not compile call site at:"
                                                     file-name line-number))]
              (c-init (.c-var call-site) (.init call-site) (.decl call-site)
                      (.type-num call-site) (.refs-map call-site))))))

  (emit-defined-value [fn-val defined-sym]
    (for [init-fn-context (sm/get-in-val [.init .fn-context])
          fn-context (reset-fn-context init-fn-context)
          value (emit fn-val)
          var (comp (map (lookup-declaration defined-sym) .c-var)
                    (global-var defined-sym "var"))
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.init .fn-context] init-fn-context)
          _ (new-module-def defined-sym (c-code var [] [] (.type-num value) {}))]
      [(c-init var [(.init value)
                    var " = " (.c-var value) ";" line-sep
                    var "->refs = -1;" line-sep]
               [(.decl value) "Value *" var ";\n"]
               (.type-num value) (.refs-map value))]))
  
  (tail-call [ast params return-constraints]
    (TailExpr ast params return-constraints))

  (replace-syms [ast subs]
    (for [target (replace-syms (.call-target ast) subs)
          args (traverse (.args ast) (fn [ast]
                                       (replace-syms ast subs)))]
      (ast/call-ast target args)))

  (inline-expr [ast arg-asts]
    ;; TODO: remove the hard-coded check for 'new-sm
    (comp (for [_ (sm/when (= 'new-sm (.call-target ast)))
                f-ast (sm/when (first (.args ast)))
                new-ast (inline-expr f-ast arg-asts)]
            new-ast)
          (for [new-call-target (inline-expr (.call-target ast) (.args ast))
                new-ast (inline-expr new-call-target arg-asts)]
            new-ast)))
  
  (replace-bound-vars [ast subs]
    (ast/call-ast (replace-bound-vars (.call-target ast) subs)
                  (map (.args ast) (fn [ast]
                                     (replace-bound-vars ast subs))))))

(defn unpack-arg-list [list-sym elem-vars file-name line-num]
  (comp (sm/when (for [elem (first elem-vars)
                       :when (= 1 (count elem-vars))
                       var (first (.vars elem))]
                   (ParamBinding [list-sym]
                                 [(c-init var ["Value *" var " = (Value *)" list-sym ";" line-sep]
                                          [] ListType {})])))
        (for [destructArgs (genlocal "destArgs")]
          (let [elem-c-vars (flat-map elem-vars .vars)
                tail-var (extract (last elem-c-vars))
                elem-count (count elem-vars)]
            (ParamBinding [list-sym]
                          (comp [(c-code ""
                                         [(map elem-c-vars (fn [var] ["Value *" var ";" line-sep]))
                                          "Value **" destructArgs "[" elem-count "] = {"
                                          (interpose (map elem-c-vars (fn [arg] ["&" arg])) ", ")
                                          "};" line-sep "destructValue(\"" file-name "\", \"" line-num
                                          "\", (Value *)" list-sym ", " elem-count ", "
                                          destructArgs ");" line-sep]
                                         [] UnknownType {list-sym 1})]
                                (map elem-c-vars (fn [var]
                                                   (c-init var [] []
                                                           ((= var tail-var) ListType UnknownType)
                                                           {})))
                                (flat-map elem-vars .destruct)))))))


(defprotocol AllSyms
  (all-symbols [ast]
    (assert-result l (instance? List l))
    (list ast)))

(extend-type ast/params-ast
  AllSyms
  (all-symbols [params]
    (comp (flat-map (.fixed params) all-symbols)
          (either (map (.variadic params) all-symbols)
                  empty-list)))

  Emitter
  (bind [params]
    (for [fixed-vars (map (traverse (.fixed params) bind) vec)
          tail-var (bind (either (.variadic params)
                                 (symbol "#tail")))
          param-var (genlocal "arg")
          destruct (unpack-arg-list param-var (conj fixed-vars tail-var)
                                    (ast/file-name params)
                                    (ast/line-number params))]
      destruct))

  (bind [params evalled]
    (for [fixed-vars (map (traverse (.fixed params) bind) vec)
          tail-var (bind (either (.variadic params)
                                 (symbol "#tail")))
          destruct (unpack-arg-list (.c-var evalled) (conj fixed-vars tail-var)
                                    (ast/file-name params) (ast/line-number params))]
      (.vars (either (and (empty? (.init evalled))
                          (empty? (.decl evalled))
                          (maybe destruct))
                     (.destruct destruct
                                (comp [evalled] (.destruct destruct))))
             [(.c-var evalled)])))

  (replace-bound-vars [ast subs]
    (let [new-fixed (map (.fixed ast) (fn [param]
                                        (replace-bound-vars param subs)))]
      (ast/params-ast new-fixed (map (.variadic ast) (fn [v]
                                                       (replace-bound-vars v subs)))))))


(extend-type ast/binding-ast
  Emitter
  (emit [ast]
    (flat-map (emit (.val ast))
              (partial bind (.binding ast)))))

(extend-type ast/let-ast
  Emitter
  (emit [ast]
    (for [locals (sm/get-in-val [.fn-context .syms])
          constraints (sm/get-in-val [.fn-context .constraints])
          bindings (emit (.bindings ast))
          body-exprs (emit (.body ast))
          _ (sm/assoc-in-val [.fn-context .syms] locals)
          ;; TODO: add any constraints from the let expr that apply outside of it
          _ (sm/assoc-in-val [.fn-context .constraints] constraints)]
      (let [code (collapse-expressions (comp (flat-map bindings .destruct) body-exprs))]
        (c-init (.c-var code) (.init code) (.decl code) (.type-num code) (.refs-map code)))))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-in-val [.init .fn-context])
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          var (comp (map (lookup-declaration defined-sym) .c-var)
                    (global-var defined-sym "var"))
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.init .fn-context] init-fn-context)
          _ (new-module-def defined-sym (c-code var [] [] (.type-num value) {}))]
      [(c-init var [(.init value)
                    var " = " (.c-var value) ";" line-sep
                    var "->refs = -1;" line-sep]
               [(.decl value) "Value *" var ";\n"]
               (.type-num value) (.refs-map value))]))

  (tail-call [ast params return-constraints]
    (.body ast (-> ast
                   .body
                   (tail-call params return-constraints))))

  (replace-syms [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (comp (for [binding-ast (sm/when (first bindings))
                          new-val (replace-syms (.val binding-ast) subs)
                          :let [new-subs (reduce (all-symbols (.binding binding-ast))
                                                 subs dissoc)]
                          new-bindings (recur (rest bindings) new-bindings new-subs)]
                      (conj new-bindings (.val binding-ast new-val)))
                    (sm/state-maybe new-bindings)))]
      (for [new-bindings (f (.bindings ast) [] subs)
            new-body (traverse (.body ast) (fn [ast]
                                             (replace-syms ast subs)))]
        (ast/let-ast (seq new-bindings) new-body))))

  (inline-expr [ast arg-asts]
    (let [unique-syms (map arg-asts (fn [_] (gensym "#arg")))]
      (-> ast
          (.bindings (comp (make-bindings unique-syms arg-asts)
                           (.bindings ast)))
          (.body (update-last (.body ast) (fn [ast]
                                            (ast/call-ast ast unique-syms))))
          (sm/state-maybe))))

  (replace-bound-vars [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (either (for [binding-ast (first bindings)]
                        (let [new-val (replace-bound-vars (.val binding-ast) subs)
                              new-subs (reduce (all-symbols (.binding binding-ast))
                                               subs (fn [new-subs sym]
                                                      (assoc new-subs sym (symbol (str "#" sym)))))
                              [new-bindings new-subs] (recur (rest bindings) new-bindings new-subs)]
                          [(conj new-bindings
                                 (ast/binding-ast (replace-bound-vars (.binding binding-ast)
                                                                      new-subs)
                                                  new-val))
                           new-subs]))
                      [new-bindings subs]))]
      (let [[new-bindings new-subs] (f (.bindings ast) empty-list subs)
            new-body (map (.body ast) (fn [ast]
                                        (replace-bound-vars ast new-subs)))]
        (ast/let-ast (seq new-bindings) new-body)))))


(defn index [coll]
  (let [coll (seq coll)]
    (zip-lists (range (count coll)) coll)))

(defn closure-reified-value [type-num impl-fns]
  (let [inits (map impl-fns .init)]
    (for [reified-sym (genlocal "reifiedDyn")
          :when-not (every inits empty?)]
      (c-init reified-sym
              [inits
               "Value *" reified-sym " = (Value *)malloc_reified("
               (count impl-fns) ");" line-sep
               "((ReifiedVal *)" reified-sym ")->type = " type-num ";" line-sep
               "((ReifiedVal *)" reified-sym ")->implCount = "
               (count impl-fns) ";" line-sep
               "((ReifiedVal *)" reified-sym ")->typeArgs = (Value *)0;" line-sep
               (-> impl-fns
                   (map .c-var)
                   (index)
                   (map (fn [[index sym]]
                          ["((ReifiedVal *)" reified-sym
                           ")->impls[" index "] = (Value *)" sym ";" line-sep])))]
              (map impl-fns .decl)
              type-num
              (apply merge-with + (map impl-fns .refs-map))))))

(defn static-reified-value [type-num impl-fns]
  (for [reified-sym (global-var "reifiedStatic")
        reified-ptr (global-var "reifiedPtr")]
    (c-code reified-ptr
            []
            [(map impl-fns .decl)
             "ReifiedVal " reified-sym " = {"
             type-num ", -1, (Value *)0, 0, {}};" line-sep
             "Value *" reified-ptr " = (Value *)&" reified-sym ";" line-sep]
            type-num {})))

(defprotocol ArityType
  (closure-arity? [_]
    (assert-result x (instance? Maybe x))
    nothing)
  (reify-arity [_ dispatch-type-num arity-ast fn-name]
    ;; (assert-result x (instance? sm/new-sm x))
    ))

(deftype StaticArity [arity-fn-var param-count return-type var-info param-constraints]
  Stringable
  (string-list [_]
    (comp (list "<StaticArity " (str arity-fn-var) " " (str param-count) " "
                (target-type-name return-type) " ")
          (string-list var-info)))

  ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name]
    (for [_ (new-proto-impl fn-name param-count dispatch-type-num var-info arity-ast)
          _ (new-static-arity (.c-var var-info) param-count arity-fn-var return-type)]
      var-info)))

(deftype ClosureArity [arity-fn-var params var-info]
  Stringable
  (string-list [_]
    (comp (list "<ClosureArity " (str arity-fn-var) " " (str params) " ")
          (string-list var-info)))

  ArityType
  (closure-arity? [arity] (maybe arity))
  (reify-arity [_ dispatch-type-num arity-ast fn-name]
    (let [param-count (count params)
          fn-arity-sym (gensym "protoFnArity")
          impl-fn-sym (gensym "protoImpl")]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            [dispArg & args] (traverse (.fixed params) (fn [arg] (genlocal arg "arg")))
            :let [arg-decls (to-str (interpose (conj (map (cons dispArg args)
                                                          (fn [arg] (str "Value *" arg)))
                                                     (str "List *closures"))
                                               ", "))
                  args (to-str (interpose (comp ["closures" dispArg] args) ", "))]
            _ (new-proto-impl fn-name param-count dispatch-type-num
                              (c-code (str "&" fn-arity-sym) [] [] FunctionType {}) arity-ast)
            _ (sm/update-in-val [.reify-fn-index] inc)]
        (let [reified-fn (c-code "" []
                                 ["// implementation of " fn-name "\n"
                                  "Value *" impl-fn-sym "(" arg-decls ") {" line-sep
                                  "FnArity *arityPtr = (FnArity *)((ReifiedVal *)" dispArg 
                                  ")->impls["
                                  reify-fn-index "];" line-sep
                                  "incRef(" dispArg ", 1);" line-sep
                                  "Value *rval = ((FnType" param-count
                                  " *)arityPtr->fn)(arityPtr->" args ");" line-sep
                                  "dec_and_free(" dispArg ", 1);" line-sep
                                  "return(rval);" line-sep
                                  "};\n\n"
                                  "FnArity " fn-arity-sym " = {FnArityType, -1, " param-count
                                  ", (List *)0, 0, " impl-fn-sym "};" line-sep]
                                 UnknownType {})]
          (comp reified-fn var-info))))))

(defn bind-params [params fn-var arity-fn-var]
  (comp (for [tail (sm/when (.variadic params))
              _ (sm/assoc-in-val [.fn-context .syms tail .type-num] ListType)
              fixed-vars (map (traverse (.fixed params) bind) vec)
              tail-var (bind tail)
              param-var (genlocal "arg")
              destruct (unpack-arg-list param-var (conj fixed-vars tail-var)
                                        (ast/file-name params)
                                        (ast/line-number params))]
          destruct)
        (for [vars (traverse (.fixed params) bind)
              :when-not (empty? vars)
              _ (sm/assoc-in-val [.fn-context .recurse fn-var (count params)] arity-fn-var)]
          (let [[var & vars] vars
                param-vars (comp* var vars)
                param-destruct (comp (map (.vars param-vars)
                                                  (fn [var]
                                                    (c-init var [] [] UnknownType {})))
                                             (.destruct param-vars))]
            (ParamBinding (.vars param-vars) param-destruct)))
        (for [_ (sm/assoc-in-val [.fn-context .recurse fn-var 0] arity-fn-var)]
          (ParamBinding [] []))))

(defn emit-closure-arity [fn-sym fn-context arity-fn-var params param-vars body-exprs]
  (for [closures (sm/get-in-val [.fn-context .closed-over .closures])
        :when-not (empty? closures)
        destArgs (genlocal "destArgs")
        _ (reset-fn-context fn-context)
        arity-var (genlocal fn-sym "dynArity")
        closure-vars (traverse closures (fn [[_ sym]] (lookup-sym sym)))]
    (let [closures (-> closures
                       (map (fn [[arg]] arg))
                       (seq)
                       (conj "closuresTail")
                       (reverse))
          closure-count (count closures)
          destruct-closures (cons (c-code ""
                                          [(map closures (fn [arg] ["Value *" arg ";" line-sep]))
                                           "incRef((Value *)closures, 1);" line-sep
                                           "Value **" destArgs "[" closure-count "] = {"
                                           (interpose (map closures (fn [arg] ["&" arg])) ", ")
                                           "};" line-sep
                                           "destructValue(\"\", \"\", (Value *)closures"
                                           ", " closure-count ", " destArgs ");" line-sep]
                                          []
                                          UnknownType {})
                                  (map closures (fn [arg] (c-init arg [] [] UnknownType {}))))
          body (collapse-expressions (comp (.destruct param-vars)
                                           destruct-closures
                                           body-exprs))
          arity-decl [(.decl body)
                      "Value *" arity-fn-var "("
                      (-> (.vars param-vars)
                          (map (fn [param] (str "Value *" param)))
                          (seq)
                          (conj "List *closures")
                          (interpose ", "))
                      ") {\nwhile (1) {\n"
                      (.init body)
                      line-sep "};};\n"]
          arity-init ["FnArity *" arity-var
                      " = malloc_fnArity();" line-sep

                      arity-var "->count = " (count (.vars param-vars))
                      ";" line-sep
                      arity-var "->variadic = "
                      ((.variadic params) "1" "0") ";" line-sep
                      arity-var "->fn = " arity-fn-var ";" line-sep
                      arity-var "->closures = empty_list;" line-sep]]
      (ClosureArity arity-fn-var params
                    (comp* (c-init arity-var arity-init arity-decl FnArityType {})
                           (map closure-vars (fn [closure]
                                               (c-code arity-var
                                                       [arity-var "->closures = listCons((Value *)"
                                                        (.c-var closure) ", (List *)" arity-var
                                                        "->closures);" line-sep]
                                                       [] ListType {(.c-var closure) 1}))))))))

(defn emit-static-arity [fn-sym fn-context arity-fn-var params param-vars param-types body-exprs]
  ;; TODO: remove the 'param-types' parameter
  (let [arity-index ((.variadic params) 'variadic (count params))]
    (for [constraints (sm/get-in-val [.fn-context .constraints])
          _ (reset-fn-context fn-context)
          arity-var (comp (for [dispatch-type (sm/when (first param-types))
                                proto-impl (get-proto-impl fn-sym arity-index dispatch-type)]
                            (.c-var proto-impl))
                          (global-var fn-sym "staticArity"))]
      (let [body (collapse-expressions (comp (.destruct param-vars) body-exprs))
            arity-decl [(.decl body)
                        "Value *" arity-fn-var "("
                        (-> (.vars param-vars)
                            (map (fn [param] (str "Value *" param)))
                            (seq)
                            (conj "List *closures")
                            (interpose ", "))
                        ") {\nwhile (1) {\n"
                        (.init body)
                        line-sep "};};\n"]]
        (do
          ;; TODO: use this to eliminate unknown return type values
          ;; (and (= UnknownType (.type-num body))
          ;;      (maybe (print-err 'unknown-return-type fn-sym
          ;;                        (ast/file-name body-exprs) (ast/line-number body-exprs))))
          (StaticArity arity-fn-var arity-index (.type-num body)
                       (c-code (str "&" arity-var) []
                               [arity-decl
                                "FnArity " arity-var " = {FnArityType, -1, "
                                (count (.vars param-vars))
                                ", (List *)0, " ((.variadic params) "1" "0")
                                ", " arity-fn-var "};" line-sep]
                               FnArityType {})
                       (map (.fixed params) (fn [param]
                                              (either (and (instance? rdr/tagged-symbol param)
                                                           (get constraints param))
                                                      [])))))))))

(defn check-result-assertions [result-asserts]
  (let [asserted-return-types (reduce result-asserts []
                                      (fn [asserted-types assertion]
                                        (either (map (assert-return-type assertion)
                                                     (fn [type-sym]
                                                       (conj asserted-types (maybe type-sym))))
                                                asserted-types)))]
    (for [asserted-type-nums (traverse asserted-return-types get-type-number)
          _ (sm/when (or (< (count asserted-type-nums) 2)
                         (flat-map (first asserted-type-nums)
                                   (fn [type-num]
                                     (=* type-num asserted-type-nums)))))]
      "")))

(defn emit-fn-arity
  ([fn-sym fn-var params param-types body]
   (flat-map (global-var fn-sym "arityImpl")
             (fn [arity-fn-var]
               (emit-fn-arity fn-sym fn-var params param-types body arity-fn-var))))
  ([fn-sym fn-var params param-types body arity-fn-var]
   (either (and (empty? (filter body produces-code?))
                (maybe (zero sm/state-maybe)))
           (let [return-constraints (filter body return-assertion?) 
                 assertions (filter body assertion?)
                 body (-> body
                          (remove assertion?)
                          (remove return-assertion?))]
             (for [fn-context (reset-fn-context)
                   _ (comp (check-result-assertions return-constraints)
                           (compilation-error "Conflicting result assertions in:"
                                              fn-sym "at:" (ast/file-name body)
                                              (ast/line-number body)
                                              (to-str (flat-map return-constraints
                                                                (fn [a]
                                                                  ["\n" (ast/file-name a)
                                                                   " " (ast/line-number a)])))))
                   _ (comp (sm/get-in-val [.fn-context .syms fn-sym])
                           (sm/assoc-in-val [.fn-context .syms fn-sym]
                                            (c-code fn-var [] [] FunctionType {})))
                   param-vars (bind-params params fn-var arity-fn-var)
                   :let [param-vars (either (and (some body (partial instance? ast/inline-ast))
                                                 (maybe (.destruct param-vars [])))
                                            param-vars)]
                   _ (traverse (zip-lists (seq (.fixed params)) (seq param-types))
                               (fn [[var type-num]] (set-type var type-num)))
                   body-exprs (-> (comp assertions return-constraints body)
                                  (tail-call (.vars param-vars) return-constraints)
                                  emit)
                   arity-info (comp (emit-closure-arity fn-sym fn-context arity-fn-var params
                                                        param-vars body-exprs)
                                    (emit-static-arity fn-sym fn-context arity-fn-var params
                                                       param-vars param-types body-exprs))]
               arity-info)))))

(defn validate-protocol-names [ast]
  (traverse (keys (.impls ast))
            (fn [protocol-name]
              (comp (get-protocol protocol-name)
                    (compilation-error "Invalid protocol:" protocol-name "in"
                                       (str (ast/file-name ast) ",")
                                       (ast/line-number protocol-name))))))

(defn validate-proto-fn-name [fn-name arg-count]
  (comp (get-protocol-dispatcher fn-name arg-count)
        (compilation-error "Invalid protocol fn:"
                           (str "'" fn-name "' in")
                           (str (ast/file-name fn-name) ",")
                           (ast/line-number fn-name))))

(deftype ProtoImplDeclaration [fn-name arity-ast arity-impl-var c-decl])

(defn declare-impl [type-str type-num [fn-name arity-ast]]
  (let [num-args (count (.params arity-ast))]
    (for [impl-fn-var (global-var fn-name "staticArity")
          arity-impl-var (global-var (str type-str fn-name) "arityImpl")
          dispatcher-info (validate-proto-fn-name fn-name num-args)
          _ (new-proto-impl fn-name num-args type-num
                            (c-code impl-fn-var [] [] (.return-type dispatcher-info) {})
                            arity-ast)
          _ (new-static-arity impl-fn-var num-args arity-impl-var (.return-type dispatcher-info))]
      (ProtoImplDeclaration fn-name arity-ast arity-impl-var
                            ["Value *" arity-impl-var "("
                             (interpose (cons "List *closures"
                                              (seq (map (-> arity-ast .params .fixed)
                                                        (fn [param]
                                                          (str "Value *")))))
                                        ", ")
                             ");\n"]))))

(defn emit-impl [type-str type-num impl-decl]
  (let [[fn-name arity-ast arity-var] (type-args impl-decl)
        num-args (count (.params arity-ast))]
    (for [dispatcher-info (validate-proto-fn-name fn-name num-args)
          ext-fn (comp (emit-fn-arity (str type-str fn-name) (.fn-var arity-ast)
                                      (.params arity-ast) [type-num]
                                      (comp (.body arity-ast)
                                            (.return-constraints dispatcher-info))
                                      arity-var)
                       (compilation-error "Could not compile protocol fn:"
                                          (str "'" fn-name "' in")
                                          (str (ast/file-name fn-name) ",")
                                          (ast/line-number fn-name)))
          reified (reify-arity ext-fn type-num arity-ast fn-name)]
      reified)))

(defn extend-type* [ast type-num]
  ;; TODO: change (.impls ast) to an a-list or something that preserves lexical order
  (let [impl-arities (for [impl-fns (vals (.impls ast))
                            [fn-name arities] (seq impl-fns)
                            impl-arity arities]
                        [fn-name impl-arity])]
    (comp (sm/when (empty? impl-arities))
          (for [type-str (comp (map (sm/get-in-val [.constants .type-names type-num])
                                    (fn [type]
                                      (str type "_")))
                               (sm/state-maybe ""))
                _ (validate-protocol-names ast)
                impl-arities (traverse impl-arities (partial declare-impl type-str type-num))
                [head-fn & fns] (traverse impl-arities (partial emit-impl type-str type-num))]
            (cons (.decl head-fn [(map impl-arities .c-decl) (.decl head-fn)])
                  fns)))))

(extend-type ast/reify-ast
  Emitter
  (emit [ast]
    (let [reified-type-num (.type-num ast)]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            _ (sm/set-val .reify-fn-index 0)
            impl-fns (extend-type* ast reified-type-num)
            _ (sm/set-val .reify-fn-index reify-fn-index)
            reified-result (comp (closure-reified-value reified-type-num impl-fns)
                                 (static-reified-value reified-type-num impl-fns))]
        reified-result)))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-in-val [.init .fn-context])
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.init .fn-context] init-fn-context)
          value (comp (map (lookup-declaration defined-sym)
                           (fn [c-info]
                             (c-code (.c-var value) [(.init value) "\n" (.c-var c-info) " = "
                                                     (.c-var value) ";" line-sep]
                                     (.decl value) (.type-num value) (.refs-map value))))
                      (sm/state-maybe value))
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] (.type-num value) {}))]
      [value]))

  (tail-call [ast params return-constraints]
    (TailExpr ast params return-constraints)))


(defn filter-vals [m f]
  (reduce (seq m) {}
          (fn [m [k v]]
            (either (map (f v) (fn [_] (assoc m k v)))
                    m))))

(defn decrement-refs [refs-map [var var-refs]]
  (either (update-in refs-map [var] (fn [refs]
                                      (- refs var-refs)))
          refs-map))

(defn cond-clause-init [cond-test expr-result [init refs-map] clause]
  (let [refs-map (-> (.refs-map clause)
                     seq
                     (reduce refs-map decrement-refs)
                     (filter-vals (partial < 0)))]
    [(conj (vec init)
           [(.init clause)
            expr-result " = " (.c-var clause) ";" line-sep
            cond-test expr-result ")) {" line-sep
            (map (seq refs-map) (fn [[c-sym remaining]]
                                  ["dec_and_free(" c-sym ", " remaining ");" line-sep]))])
     refs-map]))

(defn emit-cond-expr [result-var clauses cond-test tail-return]
    (for [evalled-clauses (-> clauses
                              (filter produces-code?)
                              emit)
          last-clause (sm/when (last evalled-clauses))]
      (let [clause-vars (-> evalled-clauses
                            (remove (fn [c] (empty? (.init c))))
                            (map .c-var)
                            set)
            refs-maps (map evalled-clauses .refs-map)
            refs-map (-> (apply merge-with + refs-maps)
                         (remove-keys clause-vars)
                         (filter-vals (partial < 0)))
            [clause-inits] (-> (butlast evalled-clauses)
                               (reduce [[] refs-map]
                                       (partial cond-clause-init cond-test result-var)))
            last-init ((= "" (.c-var last-clause))
                       (.init last-clause)
                       [(.init last-clause)
                        result-var " = " (.c-var last-clause) ";" line-sep])
            clause-inits (conj clause-inits last-init)]
        (c-init result-var
                ["Value *" result-var ";" line-sep
                 (interpose clause-inits [tail-return "} else {" line-sep
                                          "dec_and_free(" result-var ", 1);" line-sep])
                 (-> evalled-clauses
                     count
                     dec
                     (repeat (str "}" line-sep)))]
                (map evalled-clauses .decl)
                MaybeType refs-map))))

(deftype TailAnd [clauses]
  Stringable
  (string-list [expr]
    (comp (list "<TailAnd ") (flat-map clauses string-list) (list ">")))

  Emitter
  (emit [ast]
    (for [result-var (genlocal "andRslt")
          expr (emit-cond-expr result-var (.clauses ast) "if (isNothing("
                               (str "return(nothing);" line-sep))]
      expr)))


(extend-type ast/and-ast
  Emitter
  (emit [ast]
    (for [result-var (genlocal "andRslt")
          expr (emit-cond-expr result-var (.clauses ast) "if (isNothing(" "")]
      expr))

  (tail-call [ast params return-constraints]
    (let [[last-clause & clauses] (reverse (seq (.clauses ast)))]
      (TailAnd (-> (tail-call last-clause params return-constraints)
                   (cons clauses)
                   reverse))))

  (replace-syms [ast subs]
    (for [new-clauses (traverse (.clauses ast)
                                (fn [ast]
                                  (replace-syms ast subs)))]
      (.clauses ast new-clauses)))

  (replace-bound-vars [ast subs]
    (ast/and-ast (map (.clauses ast) (fn [ast]
                                       (replace-bound-vars ast subs))))))

(deftype TailOr [clauses]
  Stringable
  (string-list [expr]
    (comp (list "<TailOr ") (flat-map clauses string-list) (list ">")))

  Emitter
  (emit [ast]
    (for [result-var (genlocal "orRslt")
          expr (emit-cond-expr result-var (.clauses ast) "if (!isNothing("
                               (str "return(" result-var ");" line-sep))]
      expr)))

;; TODO: before emitting 'or', save the current constraints and reset the constraints before
;; each clause. Save the constraints after each clause and merge them all at the end.
;; Then go back and add any needed run time checks to the .init of each clause.
;; save the locals as well
(extend-type ast/or-ast
  Emitter
  (emit [ast]
    (flat-map (genlocal "orRslt")
              (fn [result-var]
                (emit-cond-expr result-var (.clauses ast) "if (!isNothing(" line-sep))))

  (tail-call [ast params return-constraints]
    (let [[last-clause & clauses] (reverse (seq (.clauses ast)))]
      (TailOr (-> (tail-call last-clause params return-constraints)
                  (cons clauses)
                  reverse))))

  (replace-syms [ast subs]
    (for [new-clauses (traverse (.clauses ast)
                                (fn [ast]
                                  (replace-syms ast subs)))]
      (.clauses ast new-clauses)))

  (replace-bound-vars [ast subs]
    (ast/or-ast (map (.clauses ast) (fn [ast]
                                      (replace-bound-vars ast subs)))))) 

(deftype TailEither [clause alt return-constraints]
  Stringable
  (string-list [expr]
    (comp (list "<TailEither ") (list ">")))

  Emitter
  (emit [ast]
    (for [cond-val (emit clause)
          alt-val (emit alt)
          result-var (genlocal "rslt")
          cond-check (emit-return-constraints (c-code result-var [] [] UnknownType {})
                                              return-constraints)
          alt-val (comp (emit-tail-expr clause
                                        (ast/file-name ast)
                                        (ast/line-number ast)
                                        return-constraints
                                        alt-val)
                        (compilation-error "Could not emit code for 'either' expression at"
                                           (str (ast/file-name clause) ":")
                                           (ast/line-number clause)))]
      (let [cond-rslt (.c-var cond-val)
            refs-map (-> (merge-with + (.refs-map cond-val)
                                     (.refs-map alt-val))
                         (filter-vals (partial < 0)))]
        (c-code ""
                [(.init cond-val)
                 "if (!isNothing(" cond-rslt ")) {" line-sep
                 (-> (.refs-map alt-val)
                     (filter-vals (partial < 0))
                     seq
                     (map (fn [[var refs]]
                            ["dec_and_free(" var ", " refs ");" line-sep])))
                 "Value *" result-var " = maybeExtract(" cond-rslt ");" line-sep
                 (map cond-check .init)
                 "return(" result-var ");" line-sep
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 "}" line-sep]
                (comp (.decl cond-val) (.decl alt-val))
                UnknownType
                refs-map)))))

;; TODO: before emitting 'either', save the current constraints and reset the constraints before
;; each clause. Save the constraints after each clause and merge them all at the end.
;; Then go back and add any needed run time checks to the .init of each clause.
;; save the locals as well
(extend-type ast/either-ast
  Emitter
  (emit [ast]
    (for [result-var (genlocal "eitherRslt")
          ;; TODO: make sure cond-val is a Maybe type in a way that propagates out
          cond-val (emit (.clause ast))
          alt-val (emit (.alt ast))]
      (let [cond-rslt (.c-var cond-val)
            refs-map (-> (merge-with + (.refs-map cond-val)
                                     (.refs-map alt-val))
                         (filter-vals (partial < 0)))]
        (c-init result-var
                [(.init cond-val)
                 "Value *" result-var ";" line-sep
                 "if (!isNothing(" cond-rslt ")) {" line-sep
                 (-> (.refs-map alt-val)
                     (filter-vals (partial < 0))
                     seq
                     (map (fn [[var refs]]
                            ["dec_and_free(" var ", " refs ");" line-sep])))
                 result-var " = maybeExtract(" cond-rslt ");" line-sep
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 result-var " = " (.c-var alt-val) ";" line-sep
                 "}" line-sep]
                (comp (.decl cond-val) (.decl alt-val))
                UnknownType
                refs-map))))

  (tail-call [ast params return-constraints]
    (TailEither (.clause ast) (.alt ast) return-constraints))

  (replace-syms [ast subs]
    (ast/either-ast (replace-syms (.clause ast) subs)
                    (replace-syms (.alt ast) subs)))

  (replace-bound-vars [ast subs]
    (ast/either-ast (replace-bound-vars (.clause ast) subs)
                    (replace-bound-vars (.alt ast) subs)))) 


(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [;; _ (debug 'main-fn)
          fn-arity (emit-fn-arity 'main "" (.params ast) [ListType] (.body ast))
          ;; _ (debug "=======")
          _ (new-static-arity 'main 1 (.arity-fn-var fn-arity) IntegerType)]
      [(c-code "" [] (.decl (.var-info fn-arity)) 0 {})])))


(defn declare-proto-dispatch-arity [fn-name dispatch-fn-var prototype]
  (let [num-args (count (.params prototype))
        type-symbol (-> prototype
                        .default-body
                        (some assert-return-type))
        return-constraints (-> prototype
                               .default-body
                               (filter return-assertion?))]
    (for [arity-fn-var (global-var fn-name "protoDisp")
          impls-sym (global-var (str fn-name "_Implementations") "protoImpls")
          return-type (get-type-number type-symbol)
          _ (new-proto-dispatcher fn-name num-args arity-fn-var impls-sym
                                  return-type return-constraints)
          _ (new-static-arity dispatch-fn-var num-args arity-fn-var return-type)]
      ["ProtoImpls " impls-sym ";\n"
       "Value *" arity-fn-var "("
       (interpose (conj (map (range num-args)
                             (fn [n]
                               (str "Value *arg" n)))
                        "List *closures")
                  ", ")
       ");\n"])))

(defn emit-proto-default [protocol-name fn-name prototype]
  (let [default-body (.default-body prototype)]
    (comp (for [_ (sm/when-not (empty? default-body))
                static-arity (emit-fn-arity (str "Default_" fn-name) ""
                                            (.params prototype) [] default-body)
                _ (new-proto-impl fn-name (count (.params prototype)) 0
                                  (.var-info static-arity) default-body)]
            (.decl (.var-info static-arity)))

          sm-space)))

(defn create-dispatcher [proto-name [fn-name arities]]
  (for [dispatch-fn-sym (global-var fn-name "dispatchFnPtr")
        _ (sm/assoc-in-val [.modules (ast/file-name fn-name) .values fn-name]
                           (c-code dispatch-fn-sym [] [] FunctionType {}))
        _ (new-protocol-fn fn-name dispatch-fn-sym)
        dispatch-arities (traverse arities
                                   (partial declare-proto-dispatch-arity fn-name
                                            dispatch-fn-sym))
        default-fns (traverse arities
                              (partial emit-proto-default proto-name fn-name))]
    ["\n// proto fn for " proto-name "/" fn-name "\n"
     "Value *" dispatch-fn-sym ";\n"
     dispatch-arities
     default-fns]))

(extend-type ast/protocol-ast
  Emitter
  (emit-definition [ast]
    (let [proto-name (.protocol-sym ast)
          prototype-map (reduce (.prototypes ast) {}
                                (fn [m prototype]
                                  (either (update m (.fn-name prototype)
                                                  (fn [prototypes]
                                                    (conj prototypes prototype)))
                                          (assoc m (.fn-name prototype) [prototype]))))]
      (for [_ (new-protocol proto-name)
            decl (traverse (seq prototype-map)
                           (partial create-dispatcher proto-name))]
        [(c-code "" [] decl UnknownType {})]))))


(extend-type ast/fn-arity-ast
  Emitter
  (emit [ast]
    ;; TODO: remove the '.param-types' field
    (emit-fn-arity (.fn-sym ast) (.fn-var ast) (.params ast) (.param-types ast) (.body ast)))

  (inline-expr [ast arg-asts]
    (sm/state-maybe (ast/let-ast (make-bindings (.fixed (.params ast)) arg-asts)
                                 (.body ast))))

  (replace-syms [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs dissoc)]
      (for [new-body (traverse (.body ast) (fn [ast]
                                             (replace-syms ast subs)))]
        (.body ast new-body))))

  (replace-bound-vars [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs
                       (fn [subs sym]
                         (assoc subs sym (symbol (str "#" sym)))))]
      (-> ast
          (.params (replace-bound-vars (.params ast) subs))
          (.body (map (.body ast) (fn [ast]
                                    (replace-bound-vars ast subs))))))))


(defn static-fn [fn-sym fn-var arities]
  (for [struct-var (global-var fn-sym "fnStruct")
        emitted-arities (traverse arities
                                  (fn [static-arity]
                                    (for [_ (new-static-arity fn-var
                                                              (.param-count static-arity)
                                                              (.arity-fn-var static-arity)
                                                              (.return-type static-arity)
                                                              (.param-constraints static-arity))]
                                      (.var-info static-arity))))]
    (let [arity-count (count emitted-arities)]
      (c-code fn-var []
              ["\n// --------- " fn-sym " -------------\n"
               "Value *" fn-var ";\n"
               (map emitted-arities .decl)
               "Function " struct-var " = {FunctionType, -1, \""
               fn-sym "\", " arity-count ", "
               "{" (to-str (interpose (map emitted-arities .c-var)
                                      ", "))
               "}};\n"
               "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]
              FunctionType {}))))

(defn closure-fn [fn-sym fn-var arities]
  (for [_ (sm/when (some arities closure-arity?))
        struct-var (global-var fn-sym "fnStruct")
        line (line-macro fn-sym (str "//creating " fn-sym))]
    (let [arity-count (count arities)
          emitted-arities (map arities .var-info)]
      (c-code fn-var
              [(map emitted-arities .init)
               line "Function *" struct-var " = malloc_function(" arity-count ");" line-sep
               struct-var "->name = \"" fn-sym "\";" line-sep
               struct-var "->arityCount = " arity-count ";" line-sep
               (map (zip-lists (map emitted-arities .c-var)
                               (range arity-count))
                    (fn [[sym index]]
                      (str struct-var "->arities[" index "] = " sym ";" line-sep)))
               "Value *" fn-var " = (Value *)" struct-var ";" line-sep]
              [(map emitted-arities .decl)]
              FunctionType
              (apply merge-with + (map emitted-arities .refs-map))))))

(extend-type ast/fn-ast
  Emitter
  (emit [ast]
    (comp (for [fn-sym (sm/when (.fn-sym ast))
                ;; _ (debug 'fn-sym fn-sym)
                fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                             (global-var fn-sym "fn"))
                arities (emit (map (.arities ast) (fn [arity]
                                                    (-> arity
                                                        (.fn-sym fn-sym)
                                                        (.fn-var fn-var)))))
                fn-expr (comp (closure-fn fn-sym fn-var arities)
                              (static-fn fn-sym fn-var arities))
                ;; _ (debug "---------")
                ]
            fn-expr)
          (for [fn-var (global-var "fn")
                arities (emit (.arities ast))
                fn-expr (comp (closure-fn 'anon fn-var arities)
                              (static-fn 'anon fn-var arities))]
            fn-expr)))

  (emit-defined-value [fn-val defined-sym]
    (for [value (emit fn-val)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] FunctionType {}))]
      [(make-c-code value)]))

  (tail-call [x params return-constraints]
    (TailExpr x params return-constraints))

  (inline-expr [ast arg-asts]
    (for [arity (sm/when (-> (.arities ast)
                             (filter (fn [arity]
                                       (= (count arg-asts) (count (.params arity)))))
                             first))
          expr (inline-expr arity arg-asts)]
      expr))

  (replace-syms [ast subs]
    (for [new-arities (traverse (.arities ast)
                                (fn [arity]
                                  (replace-syms arity subs)))]
      (.arities ast new-arities)))

  (replace-bound-vars [ast subs]
    (.arities ast (map (.arities ast) (fn [arity]
                                        (replace-bound-vars arity subs))))))

(extend-type ast/extend-ast
  Emitter
  (emit-definition [ast]
    (let [type-sym (.type ast)]
      (comp (for [type-nums (sm/when (or (and (= type-sym 'HashMap)
                                              (maybe (list BitmapIndexedType
                                                           ArrayNodeType
                                                           HashCollisionNodeType)))
                                         (and (= type-sym 'String)
                                              (maybe (list StringType
                                                           SubStringType)))))
                  fns (map (traverse type-nums (partial extend-type* ast))
                           flatten)]
              fns)
            (for [ns-path (sym-ns-path (.type ast))
                  type-num (comp (sm/get-in-val [.modules ns-path .types type-sym])
                                 (sm/get-in-val [.modules 'core .types type-sym]))
                  fn (extend-type* ast type-num)]
              fn)
            (compilation-error "Trying to extend unknown type: "
                               type-sym "at"
                               (str (ast/file-name (.type ast)) ":")
                               (ast/line-number (.type ast)))))))


(defn declare-getters [new-type-name fields]
  (traverse fields
            (fn [field]
              (let [getter-sym (rdr/tag (symbol (str "." field)) 'core 0)]
                (comp (map (sm/get-in-val [.modules 'core .proto-fns getter-sym]) (fn [_] []))
                      (for [dispatch-fn-var (global-var "dispatchFnPtr")
                            arity-fn-var1 (global-var "protoImpl")
                            impls-sym1 (global-var "protoImpls")
                            arity-fn-var2 (global-var "protoImpl")
                            impls-sym2 (global-var "protoImpls")
                            _ (new-module-def getter-sym (c-code dispatch-fn-var [] []
                                                                 FunctionType {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym]
                                               (ProtoFnInfo getter-sym dispatch-fn-var {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym]
                                               (ProtoFnInfo getter-sym dispatch-fn-var {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym .dispatchers 1]
                                               (ProtocolDispatcher 1 arity-fn-var1 impls-sym1
                                                                   UnknownType empty-list {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym .dispatchers 2]
                                               (ProtocolDispatcher 2 arity-fn-var2 impls-sym2
                                                                   UnknownType empty-list {}))
                            _ (new-static-arity dispatch-fn-var 1 arity-fn-var1 UnknownType)
                            _ (new-static-arity dispatch-fn-var 2 arity-fn-var2 UnknownType)]
                        ["ProtoImpls " impls-sym1 ";\n"
                         "ProtoImpls " impls-sym2 ";\n"
                         "Value *" dispatch-fn-var ";\n"
                         "Value *" arity-fn-var1
                         "(List *closures, Value *arg);\n"
                         "Value *" arity-fn-var2
                         "(List *closures, Value *arg1, Value *arg2);\n"]))))))

(defn constructor-expr [new-type-name type-val-sym fields]
  (ast/definition new-type-name
    [(ast/reified (extract rdr/type-counter)
                  {Type-sym
                   [[type-name-sym
                     [(ast/fn-arity-ast (str new-type-name "_const_type_name") ""
                                        (ast/params ['_]) "" []
                                        [(str "*" new-type-name " constructor*")])]]
                    [instance?-sym
                     [(ast/fn-arity-ast (str new-type-name "_instance_QMARK_") ""
                                        (ast/params ['x 'y]) "" []
                                        [(ast/call-ast =*-sym
                                                       [(ast/call-ast get-type-sym [type-val-sym])
                                                        (ast/call-ast get-type-sym ['y])])])]]]

                   Function-sym
                   [[invoke-sym
                     [(ast/fn-arity-ast (str new-type-name "_invoke") ""
                                        (ast/params (vec (cons '_ (seq fields)))) "" []
                                        [(ast/call-ast new-type-value-sym
                                                       [type-val-sym (ast/call-ast 'vector (seq fields))])])]]]

                   Stringable-sym
                   [[string-list-sym
                     [(ast/fn-arity (ast/params ['z]) ""
                                    [(ast/call-ast list-sym
                                                   ["<TypeCon " (str new-type-name) " ["
                                                    (to-str (interpose fields ", ")) "]>"])])]]]})]))

(defn type-val-expr [type-sym type-val-sym fields impls]
  (let [x* (symbol "#x")
        y* (symbol "#y")
        field* (symbol "#field")]
    (ast/definition type-val-sym
      [(ast/reified (extract rdr/type-counter)
                    (merge-with comp
                                {Type-sym
                                 [[type-name-sym
                                   [(ast/fn-arity-ast (str type-sym "_type_name") ""
                                                      (ast/params [x*]) "" []
                                                      [(str type-sym)])]]
                                  [has-field-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_has_field") ""
                                     (ast/params [x* field*]) "" []
                                     [(ast/or-ast
                                       (map fields
                                            (fn [field]
                                              (ast/call-ast identical-sym
                                                            [(rdr/tag (symbol (str "." field)))
                                                             field*]))))])]]]

                                 Eq-sym
                                 [[=*-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_EQ_STAR_") ""
                                     (ast/params [x* y*]) "" []
                                     [(ast/and-ast
                                       (list (ast/call-ast
                                              =*-sym [(ast/call-ast get-type-sym [x*])
                                                      (ast/call-ast get-type-sym [y*])])
                                             (ast/call-ast
                                              =*-sym [(ast/call-ast 'type-args [x*])
                                                      (ast/call-ast 'type-args [y*])])))])]]]

                                 Associative-sym
                                 [[get-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_get") ""
                                     (ast/params [x* field*]) "" []
                                     [(ast/and-ast
                                       (list
                                        (ast/call-ast has-field-sym [x* field*])
                                        (ast/call-ast maybe-sym
                                                      [(ast/call-ast field* (list x*))])))])]]]

                                 HashMapNode-sym
                                 [[assoc*-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_assoc_STAR_") ""
                                     (ast/params [x* field* 'new-value '_ '_]) "" []
                                     [(ast/call-ast
                                       extract-sym
                                       [(ast/or-ast
                                         (list (ast/and-ast
                                                (list
                                                 (ast/call-ast has-field-sym [x* field*])
                                                 (ast/call-ast
                                                  maybe-sym
                                                  [(ast/call-ast field* (list x* 'new-value))])))
                                               (ast/call-ast maybe-sym [x*])))])])]]]}
                                impls))])))

(defn create-getters [sym fields]
  (let [type-value (symbol "#value")
        new-value (symbol "#new-value")]
    {Type-sym
     (map (zip-lists (seq fields) (range (count fields)))
          (fn [[field field-index]]
            [(rdr/tag  (symbol (str "." field)))
             [(ast/fn-arity-ast (str sym "_" field) ""
                                (ast/params [type-value new-value]) "" []
                                [(ast/call-ast
                                  make-value-sym
                                  [type-value
                                   (ast/call-ast extract-sym
                                                 [(ast/call-ast store-sym
                                                                [(ast/call-ast
                                                                  reified-type-args-sym
                                                                  [type-value])
                                                                 field-index new-value])])])])
              (ast/fn-arity-ast (str sym "_" field) ""
                                (ast/params [type-value]) "" []
                                [(ast/call-ast
                                  extract-sym
                                  [(ast/call-ast
                                    nth-sym [(ast/call-ast reified-type-args-sym
                                                                  [type-value])
                                                    field-index])])])]]))}))

(defn destructure-fields [sym ast]
  (map-vals (.impls ast)
            (fn [impl-arities]
              (map impl-arities
                   (fn [[fn-name impls]]
                     [fn-name (map impls
                                   (fn [arity]
                                     (let [[type-value-parameter] (.fixed (.params arity))
                                           return-constraints (filter (.body arity)
                                                                      return-assertion?) 
                                           new-body (comp return-constraints
                                                          [(ast/let-ast [(ast/binding (.fields ast)
                                                                           (ast/call-ast
                                                                            reified-type-args-sym
                                                                            [type-value-parameter]))]
                                                                        (.body arity))])]
                                       (-> arity
                                           (.body new-body)
                                           (.fn-sym (str sym "_" fn-name))))))])))))

(extend-type ast/type-ast
  Emitter
  (emit-definition [ast]
    (let [file-name (ast/file-name ast)
          sym (.sym ast)
          fields (.fixed (.fields ast))
          const-arity-index (inc (count fields))
          impls (merge-with comp
                            (create-getters sym fields)
                            (destructure-fields sym ast))]
      (comp (for [_ (sm/get-in-val [.modules file-name .types sym])
                  _ (compilation-error (str "Trying to re-define type name: '" sym "' in module "
                                            file-name ", " (ast/line-number ast)))]
              "")
            
            (for [type-val-sym (global-var "#type-val-")
                  :let [type-val-sym (rdr/tag type-val-sym
                                              (ast/file-name sym)
                                              (ast/line-number sym))]
                  type-val-decl (emit-definition (ast/declaration-ast type-val-sym))
                  getters (declare-getters sym fields)

                  type-constructor (emit-definition (constructor-expr sym type-val-sym fields))
                  const-type-num (sm/get-in-val [.modules file-name .values sym .type-num])

                  type-val-def (emit-definition (type-val-expr sym type-val-sym fields impls))
                  type-num (sm/get-in-val [.modules file-name .values type-val-sym .type-num])
                  constructor-arity (get-proto-impl invoke-sym const-arity-index const-type-num)
                  _ (sm/assoc-in-val [.fns (.c-var constructor-arity) const-arity-index .type-num]
                                     type-num)
                  _ (sm/assoc-in-val [.modules file-name .types sym] type-num)]
              (comp type-val-decl
                    [(c-code "" [] (flatten getters) UnknownType {})]
                    type-constructor
                    type-val-def))))))

(def global-context (GlobalContext (FunctionArityContext {} 0 {} {}
                                                         empty-closures {})
                                   (RuntimeInit (FunctionArityContext {} 0 {} {}
                                                                      empty-closures {})
                                                [])
                                   {}                       ;; map for module info
                                   {}                       ;; map for static fns
                                   {}                       ;; map for namespaces
                                   (ConstantValues {} {} {} type-names)
                                   0                        ;; reify-fn-index 
                                   {}                       ;; other
                                   ))

(def string-writer (agent ""))

(def logger (agent ""))
(defn log [& msg]
  (send logger (fn [_]
                 (apply print-err msg))))

(defprotocol StringWriter
  (write-str [x]
    (print x)))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str)))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str)))

(defprotocol FreeGlobal
  (free-global [_]
    (assert-result x (instance? Vector x))
    []))

(extend-type c-init
  FreeGlobal
  (free-global [c-info]
    ["freeGlobal(" (.c-var c-info) ");" line-sep]))

(defn write-strings [strs]
  (send string-writer (fn [_]
                        (write-str strs))))

(def emit-main*
  (for [main-fn (comp (lookup-static-arity 'main 1)
                      (compilation-error "'main' function is missing"))
        values (sm/get-in-val [.init .exprs])]
    (write-strings ["\nint main (int argc, char **argv) {\n"
                    "maybeNothing = maybe((List *)0, (Value *)0, nothing);\n"
                    "maybeNothing->refs = -1;\n"
                    "outstream = stdout;\n"
                    "__atomic_store(&futuresQueue.input, &empty_list, __ATOMIC_RELAXED);\n"
                    "futuresQueue.output = empty_list;\n"
                    "pthread_mutex_init(&futuresQueue.mutex, NULL);\n"
                    "pthread_cond_init(&futuresQueue.notEmpty, NULL);\n"
                    "pthread_mutex_init(&shutDown.access, NULL);\n"
                    "startWorkers();\n"
                    (map values .init) "\n"
                    "  List *argList = malloc_list();\n"
                    "  argList->len = 0;\n"
                    "  argList->head = (Value *)0;\n"
                    "  argList->tail = (List *)0;\n"
                    "  List *tail = argList;\n"
                    "  for(int i = 0; i < argc; i++) {\n"
                    "     List *newTail = malloc_list();\n"
                    "     newTail->len = 0;\n"
                    "     newTail->tail = (List *)0;\n"
                    "     newTail->head = (Value *)0;\n"
                    "     tail->head = stringValue(argv[i]);\n"
                    "     tail->tail = newTail;\n"
                    "     tail = newTail;\n"
                    "     argList->len++;\n}\n"
                    "  argList->refs = -1;\n"
                    "Value *the_final_answer = " (.c-var main-fn)
                    "((List *)empty_list, (Value *)argList);\n\n"
                    "#ifdef CHECK_MEM_LEAK\n"
                    (map values free-global)
                    "  cleanupMemory(the_final_answer, maybeNothing, argList);\n"
                    "  if (malloc_count - free_count != 0)\n"
                    "    return(1);\n"
                    "#endif\n"
                    "  return(0);\n};\n"])))

(defn emit-proto-dispatcher [fn-name proto-disp]
  (let [num-args (.arg-count proto-disp)
        args (map (range num-args) (partial str "arg"))
        impls-sym (.impls-sym proto-disp)
        impls (.type-impls proto-disp)
        arity-sym (gensym "protoFnArity")
        dispatcher (StaticArity
                    (str "&" arity-sym) num-args UnknownType
                    (c-code (str "&" arity-sym)
                            []
                            ["\n// " fn-name " " num-args " args\n"
                             "ProtoImpls " impls-sym " = {"
                             (count impls) ", {"
                             (rest (flat-map (vals impls)
                                             ;; [type arity-sym fn-sym]
                                             (fn [type-impl]
                                               [", " "{" (.dispatch-type type-impl)
                                                ", (Value *)" (.c-var type-impl)
                                                "}"])))
                             "}};\n"
                             "Value *" (.dispatch-sym proto-disp) "("
                             (interpose (conj (map args (fn [arg] (str "Value *" arg)))
                                              "List *closures")
                                        ", ")
                             ") {\n"
                             "  return(proto" num-args "Arg(&" impls-sym ", \""
                             fn-name "\", " (interpose
                                             (comp args
                                                   [(str "\"" (ast/file-name fn-name) "\"")
                                                    (ast/line-number fn-name)])
                                             ", ")
                             "));\n}\n"
                             "FnArity " arity-sym " = {FnArityType, -1, "
                             num-args ", (List *)0, 0, " (.dispatch-sym proto-disp) "};\n"]
                            FnArityType {})
                    [])]
    (sm/state-maybe dispatcher)))

(defn emit-proto-fn [proto-fn]
  (let [fn-sym (gensym "protoFn")]
    (for [arities (traverse (vals (.dispatchers proto-fn))
                            (partial emit-proto-dispatcher (.fn-sym proto-fn)))]
      (c-code "" []
              [(map arities (fn [arity] (.decl (.var-info arity))))
               "Function " fn-sym " = {FunctionType, -1, \""
               (.fn-sym proto-fn) "\", " (count arities) ", {"
               (interpose (map arities .arity-fn-var) ", ")
               "}};\n" "Value *" (.disp-sym proto-fn) " = (Value *)&" fn-sym ";\n\n"]
              UnknownType {}))))

(defn get-proto-dispatch-sym [fn-name num-args]
  (sm/get-in-val [.modules 'core .proto-fns fn-name .dispatchers num-args .dispatch-sym]))

(def ast-emitter (agent (maybe global-context)))

(defn update-context [context update]
  (flat-map (flat-map context update) second))

(defn new-module [context module-name]
  (update-context context
                  (comp (sm/get-in-val [.modules module-name])
                        (sm/assoc-in-val [.modules module-name]
                                         (Module module-name {} {} {} core-types {}))
                        (compilation-error "Compilation error (Could not prepare new module"
                                           module-name ".)"))))

(defn emit-ast [context ast]
  (update-context context
                  (comp (for [emitted (emit-definition ast)
                              :let [_ (map emitted (fn [expr]
                                                     (write-strings (.decl expr))))]
                              _ (sm/update-in-val [.init .exprs] (fn [exprs]
                                                                   (comp exprs emitted)))]
                          "")
                        (compilation-error "Could not emit code for expression at "
                                           (ast/file-name ast) (ast/line-number ast)))))

(defn emit-main [context]
  (update-context context
                  (comp emit-main*
                        (compilation-error "Compilation error (Could not emit 'main' function.)"))))

(def finalize-protocols*
  (for [modules (map (sm/get-val .modules) vals)
        dispatchers (traverse (for [module modules
                                    proto-fn (vals (.proto-fns module))]
                                proto-fn)
                              emit-proto-fn)]
    (map dispatchers (fn [expr] (write-strings (.decl expr))))))

(defn finalize-protocols [context]
  (assert (instance? Maybe context))
  (update-context context
                  (comp finalize-protocols*
                        (compilation-error "Compilation error (Could not finalize protocols.)"))))

(def fixup-native-symbols*
  (apply-to (fn [& decl]
              (write-strings decl))
            (map (get-proto-dispatch-sym (rdr/tag 'type-name) 1)
                 (fn [arity-sym]
                   ["Value *(*type_name)(List *, Value *) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'invoke) 1)
                 (fn [arity-sym]
                   ["Value *(*invoke0Args)(List *, Value *) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'invoke) 2)
                 (fn [arity-sym]
                   ["Value *(*invoke1Arg)(List *, Value *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'invoke) 3)
                 (fn [arity-sym]
                   ["Value *(*invoke2Args)(List *, Value *, Value*, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag '=*) 2)
                 (fn [arity-sym]
                   ["Value *(*equalSTAR)(List *, Value *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'hash-seq) 2)
                 (fn [arity-sym]
                   ["Value *(*hashSeq)(List *, Value*, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'count) 1)
                 (fn [arity-sym]
                   ["Value *(*count)(List *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'sha1) 1)
                 (fn [arity-sym]
                   ["Value *(*sha1)(List *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'assoc*) 5)
                 (fn [arity-sym]
                   ["Value *(*assoc)(List *, Value*, Value*, Value*, Value*, Value*) = "
                    arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'dissoc*) 4)
                 (fn [arity-sym]
                   ["Value *(*dissoc)(List *, Value*, Value*, Value*, Value*) = "
                    arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'get*) 5)
                 (fn [arity-sym]
                   ["Value *(*get)(List *, Value*, Value*, Value*, Value*, Value*) = "
                    arity-sym ";\n"]))

            (map (lookup-core-fn-arity (rdr/tag 'show) 1)
                 (fn [arity-sym]
                   ["Value *(*showFn)(List *, Value *) = " (.c-var arity-sym) ";\n"]))

            (map (lookup-core-fn-arity (rdr/tag 'fn-apply) 2)
                 (fn [arity-sym]
                   ["Value *(*fn_apply)(List *, Value*, Value*) = "
                    (.c-var arity-sym) ";\n"]))))

(defn fixup-native-symbols [context]
  (assert (instance? Maybe context))
  (update-context context
                  (comp fixup-native-symbols*
                        (compilation-error "Compilation error (Could not fixup native symbols.)"))))

(defn file-directory [src-file-name]
  (map (sys/realpath src-file-name)
       (fn [real-path]
         (let [[path-len] (reduce real-path [-1 0]
                                  (fn [[slash-pos c-pos] c]
                                    (let [c-pos (inc c-pos)]
                                      ((= c "/")
                                       [c-pos c-pos]
                                       [slash-pos c-pos]))))]
           (subs real-path 0 path-len)))))

(def compile-module)
(def module-compiler (agent {}))

(defprotocol ASTEmitter
;; does this need to be part of the protocol? it's only used once, and only monomorphically.
  (send-to-emitter [ast]
    (send ast-emitter emit-ast ast))
  (add-namespace [ast root-dir proj-dir])
  (load-module [ast root-dir proj-dir]))

(extend-type ast/module-ast
  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [waiter (promise)
          file-path (str root-dir (.file-path ast))]
      (send module-compiler compile-module file-path waiter root-dir proj-dir)
      [waiter file-path])))

(def clone-repo)
(def repo-cloner (agent {}))

(defn clone-repo* [ast root-dir proj-dir]
  (let [opts (.args ast) 
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        branch (either (or (get opts 'tag)
                           (get opts 'branch))
                       "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)]
    (either (and (sys/sh-proc "/usr/bin/git" (list "clone" "--branch" branch
                                                   (.repo ast) dep-path))
                 (or (map (get opts 'sha)
                          (fn [sha]
                            ;; working with the OS. Give it a chance to catch up
                            (sys/sleep 3)
                            (or (sys/sh-proc "/usr/bin/git"
                                             (list "-C" dep-path "checkout" sha))
                                (do
                                  (print-err "Failed checkout of" sha "in" dep-path)
                                  (abort)))
                            (sys/sleep 3)))
                     (maybe (sys/sleep 3))))
            (do
              (print-err "Cloning git dependency" (.repo ast) "failed.")
              (abort)))
    dep-path))

(defn clone-repo [cloned ast waiter root-dir proj-dir]
  (let [opts (.args ast) 
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)
        module-path (str dep-path "/" (.file ast))]
    (either (or (map (sys/access module-path) (fn [_]
                                                (deliver waiter dep-path)
                                                cloned))
                (and (sys/access dep-path)
                     (do
                       (print-err "Dependency file" (.file ast)
                                  "missing from existing copy of repository"
                                  (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
                       (abort)))
                (update cloned dep-path (fn [cloning-future]
                                          (map cloning-future (partial deliver waiter))
                                          cloning-future))) 
            (assoc cloned dep-path (future (fn []
                                             (let [dep-path (clone-repo* ast root-dir proj-dir)]
                                               (deliver waiter dep-path)
                                               dep-path)))))))

(extend-type ast/git-dep-ast
  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [file (.file ast)]
      (or (-> file
              seq 
              (filter (partial = "/"))
              empty?)
          (do
            (print-err "For git dependencies,"
                       "files may only be imported from root of repository,"
                       file "is invalid.")
            (abort)))

      (let [clone-waiter (promise)
            dep-path (do
                       (send repo-cloner clone-repo ast clone-waiter root-dir proj-dir)
                       (extract clone-waiter))
            waiter (promise)
            module-path (str dep-path "/" file)]
        (or (sys/access module-path)
            (do
              (print-err "Dependency file" file "missing from cloned repository"
                         (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
              (abort)))
        (send module-compiler compile-module module-path waiter (str dep-path "/") proj-dir)
        [waiter module-path]))))

(extend-type ast/add-ns-ast
  ASTEmitter
  (add-namespace [ast root-dir proj-dir]
    (let [[waiter mod-file-name] (load-module (.mod ast) root-dir proj-dir)]
      (send ast-emitter
            (fn [context]
              (update-context context
                              (sm/assoc-in-val [.namespaces (ast/file-name ast) (.ns-sym ast)]
                                               mod-file-name))))
      waiter)))

(def analyze-forms
  (rd/parser (grmr/none-or-more
              (grmr/any
               (grmr/apply-fn (fn [modules]
                                (map modules extract))
                              (grmr/one-or-more
                               (grmr/apply-fn add-namespace
                                              rdr/read-add-ns
                                              (grmr/get-value 'root-directory)
                                              (grmr/get-value 'project-directory))))
                ;; using send-to-emitter here means we can't use analyze-forms for anything but emitting C code.
               (grmr/apply-fn send-to-emitter
                              rdr/top-level)))))

(def path-to-core (extract (or (map (sys/get-environment "TOCCATA_DIR")
                                    (fn [toc-dir]
                                      (str toc-dir "/core.toc")))
                               (do
                                 (print-err "Could not read environnment variable"
                                            "TOCCATA_DIR")
                                 (abort)))))

(defn load-core [modules]
  (either (or (and (get modules 'core)
                   (maybe modules))
              (for [file-in (fio/file-in path-to-core)
                    :let [_ (send ast-emitter new-module 'core)]
                    _ (analyze-forms {'file-name 'core
                                      'line-number 1
                                      'project-directory ""
                                      'root-directory ""}
                                     (lazy-list file-in))]
                (assoc modules 'core 'loaded)))
          (do
            (print-err "Could not compile Toccata core."
                       "Is the $TOCCATA_DIR environment variable set correctly?")
            (abort))))

(defn compile-module [loaded-modules file-name waiter-prom root-dir proj-dir]
  (let [loaded-modules (load-core loaded-modules)]
    (either (map (get loaded-modules file-name)
                 (fn [loaded]
                   (map loaded (fn [_]
                                 (deliver waiter-prom file-name)))
                   loaded-modules))
            (assoc loaded-modules file-name
                   (future (fn []
                             (either (flat-map (fio/file-in file-name)
                                               (fn [file-in]
                                                 (send ast-emitter new-module file-name)
                                                 (analyze-forms {'file-name file-name
                                                                 'root-directory root-dir
                                                                 'project-directory proj-dir
                                                                 'line-number 1}
                                                                (lazy-list file-in))))
                                     (do
                                       (print-err "Could not compile" file-name)
                                       (abort)))
                             (deliver waiter-prom file-name)))))))


(main [params]
      (let [[_ file-name] params
            waiter (promise)]
        (or (map (file-directory file-name)
                 (fn [root-dir]
                   (write-strings ["\n#define _XOPEN_SOURCE 600"
                                   "\n#include <stdlib.h>"
                                   "\n#include \"core.h\"\n"])
                   (send module-compiler compile-module file-name waiter root-dir root-dir)))
            (do
              (print-err "Could not find " (str "'" file-name "'"))
              (abort)))
        (extract waiter)
        ;; Are separate compilation units supported?
        (send ast-emitter emit-main)
        (send ast-emitter finalize-protocols)
        (send ast-emitter fixup-native-symbols)
        ;; (send ast-emitter (fn [ctxt]
        ;;                     (print-err
        ;;                      "\n" 'static-fixed (get-in ctxt ['_ .other 'static-fixed-sites])
        ;;                      "\n" 'static-variadic (get-in ctxt ['_ .other 'static-variadic-sites])
        ;;                      "\n" 'invoke (get-in ctxt ['_ .other 'invoke-sites])
        ;;                      "\n" 'dyn-fn (get-in ctxt ['_ .other 'dyn-fn-sites])
        ;;                      "\n" 'dyn-unknown (get-in ctxt ['_ .other 'dyn-unknown-sites])
        ;;                      "\n" 'type-known (get-in ctxt ['_ .other 'type-known-sites])
        ;;                      "\n" 'type-unknown (get-in ctxt ['_ .other 'type-unknown-sites])
        ;;                      "\n")))
        ;; wait for agents to clear their queues
        (let [waiter (promise)]
          (send ast-emitter (fn [_]
                              (send string-writer (fn [_]
                                                    (deliver waiter 'x)))))
          (extract waiter))))

